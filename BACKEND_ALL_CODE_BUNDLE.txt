===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\.gitattributes =====
/gradlew text eol=lf
*.bat text eol=crlf
*.jar binary

===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\.gitattributes =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\.gitignore =====
HELP.md
.gradle
build/
!gradle/wrapper/gradle-wrapper.jar
!**/src/main/**/build/
!**/src/test/**/build/

### STS ###
.apt_generated
.classpath
.factorypath
.project
.settings
.springBeans
.sts4-cache
bin/
!**/src/main/**/bin/
!**/src/test/**/bin/

### IntelliJ IDEA ###
.idea
*.iws
*.iml
*.ipr
out/
!**/src/main/**/out/
!**/src/test/**/out/

### NetBeans ###
/nbproject/private/
/nbbuild/
/dist/
/nbdist/
/.nb-gradle/

### VS Code ###
.vscode/

===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\.gitignore =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\.infisical.json =====
{
    "workspaceId": "eb5fe82c-b299-41dd-8e3b-4733cb76c45d",
    "defaultEnvironment": "",
    "gitBranchToEnvironmentMapping": null
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\.infisical.json =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\build.gradle.kts =====
// path: build.gradle.kts
plugins {
    java
    id("org.springframework.boot") version "3.3.5" apply false
    id("io.spring.dependency-management") version "1.1.6" apply false
}

allprojects {
    group = "com.securitybusinesssuite"
    version = "1.0.0"

    repositories {
        mavenCentral()
    }
}

subprojects {
    apply(plugin = "java")
    apply(plugin = "io.spring.dependency-management")

    java {
        sourceCompatibility = JavaVersion.VERSION_21
        targetCompatibility = JavaVersion.VERSION_21
    }

    tasks.withType<JavaCompile> {
        options.encoding = "UTF-8"
    }

    tasks.withType<Test> {
        useJUnitPlatform()
    }
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\build.gradle.kts =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\build.gradle.kts =====
// path: business/build.gradle.kts
plugins {
    id("org.springframework.boot") apply false
    id("io.spring.dependency-management")
}

dependencies {
    implementation(project(":data"))

    implementation("org.springframework.boot:spring-boot-starter-web")
    implementation("org.springframework.boot:spring-boot-starter-validation")
    implementation("org.springframework.boot:spring-boot-starter-mail")
    implementation("org.springframework.boot:spring-boot-starter-security")
    implementation ("org.springframework.boot:spring-boot-starter-data-jpa")
    implementation("io.jsonwebtoken:jjwt-api:0.12.6")
    runtimeOnly("io.jsonwebtoken:jjwt-impl:0.12.6")
    runtimeOnly("io.jsonwebtoken:jjwt-jackson:0.12.6")

    implementation("org.passay:passay:1.6.5")
    implementation("jakarta.servlet:jakarta.servlet-api")

    compileOnly("org.projectlombok:lombok:1.18.34")
    annotationProcessor("org.projectlombok:lombok:1.18.34")

    testImplementation("org.springframework.boot:spring-boot-starter-test")
}

dependencyManagement {
    imports {
        mavenBom("org.springframework.boot:spring-boot-dependencies:3.3.5")
    }
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\build.gradle.kts =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\config\DominicanTaxConfig.java =====
// path: business/src/main/java/com/securitybusinesssuite/business/config/DominicanTaxConfig.java
package com.securitybusinesssuite.business.config;

import org.springframework.stereotype.Component;
import java.math.BigDecimal;

@Component
public class DominicanTaxConfig {
    public static final BigDecimal ITBIS_RATE = new BigDecimal("0.18");
    public static final String DEFAULT_SERVICE_CODE = "SF-0001";
    public static final String DEFAULT_SERVICE_DESCRIPTION = "SERVICIO SEGURIDAD PRIVADA";
    public static final String DEFAULT_CURRENCY = "DOP";
    public static final String RNC_PATTERN = "\\d{3}-\\d{7}-\\d{1}";

    public BigDecimal getItbisRate() {
        return ITBIS_RATE;
    }

    public String getDefaultServiceCode() {
        return DEFAULT_SERVICE_CODE;
    }

    public String getDefaultServiceDescription() {
        return DEFAULT_SERVICE_DESCRIPTION;
    }
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\config\DominicanTaxConfig.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\dto\AuthResponse.java =====
// path: business/src/main/java/com/securitybusinesssuite/business/dto/AuthResponse.java
package com.securitybusinesssuite.business.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class AuthResponse {
    private String message;
    private UserDto user;
    private boolean requiresEmailVerification;
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\dto\AuthResponse.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\dto\clientrequest\CreateClientRequestDTO.java =====
// path: business/src/main/java/com/securitybusinesssuite/business/dto/CreateClientRequestDTO.java
package com.securitybusinesssuite.business.dto.clientrequest;

import com.securitybusinesssuite.data.entity.Client;
import jakarta.validation.constraints.*;
import lombok.Data;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.List;

@Data
public class CreateClientRequestDTO {
    @NotBlank(message = "Business name is required")
    @Size(max = 255, message = "Business name cannot exceed 255 characters")
    private String businessName;

    @NotNull(message = "Client type is required")
    private Client.ClientType clientType;

    @Pattern(regexp = "\\d{3}-\\d{7}-\\d{1}", message = "RNC must be in format XXX-XXXXXXX-X")
    private String rnc;

    @Size(max = 100, message = "Contact person cannot exceed 100 characters")
    private String contactPerson;

    private Client.BusinessSector businessSector;

    @Pattern(regexp = "^[+]?[\\d\\s\\-()]+$", message = "Invalid phone number format")
    private String phone;

    @Email(message = "Invalid email format")
    private String email;

    private String streetName;
    private String streetNumber;
    private String sector;
    private String provincia;

    private List<Client.SecurityService> services;

    private boolean hasContract;
    private LocalDate contractStartDate;
    private LocalDate contractEndDate;
    private boolean autoRenewal = true;

    private Client.PaymentMethod paymentMethod;

    @DecimalMin(value = "0.0", inclusive = false, message = "Hourly rate must be positive")
    private BigDecimal hourlyRate;

    private String notes;
}

===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\dto\clientrequest\CreateClientRequestDTO.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\dto\clientrequest\UpdateClientRequestDTO.java =====
// path: business/src/main/java/com/securitybusinesssuite/business/dto/UpdateClientRequestDTO.java
package com.securitybusinesssuite.business.dto.clientrequest;

import com.securitybusinesssuite.data.entity.Client;
import jakarta.validation.constraints.*;
import lombok.Data;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.List;

@Data
public class UpdateClientRequestDTO {
    @NotBlank(message = "Business name is required")
    @Size(max = 255, message = "Business name cannot exceed 255 characters")
    private String businessName;

    @NotNull(message = "Client type is required")
    private Client.ClientType clientType;

    @Pattern(regexp = "\\d{3}-\\d{7}-\\d{1}", message = "RNC must be in format XXX-XXXXXXX-X")
    private String rnc;

    @Size(max = 100, message = "Contact person cannot exceed 100 characters")
    private String contactPerson;

    private Client.BusinessSector businessSector;

    @Pattern(regexp = "^[+]?[\\d\\s\\-()]+$", message = "Invalid phone number format")
    private String phone;

    @Email(message = "Invalid email format")
    private String email;

    private String streetName;
    private String streetNumber;
    private String sector;
    private String provincia;

    private List<Client.SecurityService> services;

    private boolean hasContract;
    private LocalDate contractStartDate;
    private LocalDate contractEndDate;
    private boolean autoRenewal;

    private Client.PaymentMethod paymentMethod;

    @DecimalMin(value = "0.0", inclusive = false, message = "Hourly rate must be positive")
    private BigDecimal hourlyRate;

    @NotNull(message = "Status is required")
    private Client.ClientStatus status;

    private String notes;
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\dto\clientrequest\UpdateClientRequestDTO.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\dto\ClientResponseDTO.java =====
// path: business/src/main/java/com/securitybusinesssuite/business/dto/ClientResponseDTO.java
package com.securitybusinesssuite.business.dto;

import com.securitybusinesssuite.data.entity.Client;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.List;
import java.util.UUID;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ClientResponseDTO {
    private UUID id;
    private String clientCode;
    private String rnc;
    private Client.ClientType clientType;
    private String businessName;
    private String contactPerson;
    private Client.BusinessSector businessSector;
    private String phone;
    private String email;
    private String streetName;
    private String streetNumber;
    private String sector;
    private String provincia;
    private List<Client.SecurityService> services;
    private boolean hasContract;
    private LocalDate contractStartDate;
    private LocalDate contractEndDate;
    private boolean autoRenewal;
    private Client.PaymentMethod paymentMethod;
    private BigDecimal hourlyRate;
    private boolean requiresNcf;
    private boolean requiresRnc;
    private boolean appliesItbis;
    private Client.ClientStatus status;
    private String notes;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;

    public static ClientResponseDTO fromEntity(Client client) {
        return ClientResponseDTO.builder()
                .id(client.getId())
                .clientCode(client.getClientCode())
                .rnc(client.getRnc())
                .clientType(client.getClientType())
                .businessName(client.getBusinessName())
                .contactPerson(client.getContactPerson())
                .businessSector(client.getBusinessSector())
                .phone(client.getPhone())
                .email(client.getEmail())
                .streetName(client.getStreetName())
                .streetNumber(client.getStreetNumber())
                .sector(client.getSector())
                .provincia(client.getProvincia())
                .services(client.getServices())
                .hasContract(client.isHasContract())
                .contractStartDate(client.getContractStartDate())
                .contractEndDate(client.getContractEndDate())
                .autoRenewal(client.isAutoRenewal())
                .paymentMethod(client.getPaymentMethod())
                .hourlyRate(client.getHourlyRate())
                .requiresNcf(client.isRequiresNcf())
                .requiresRnc(client.isRequiresRnc())
                .appliesItbis(client.isAppliesItbis())
                .status(client.getStatus())
                .notes(client.getNotes())
                .createdAt(client.getCreatedAt())
                .updatedAt(client.getUpdatedAt())
                .build();
    }
}

===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\dto\ClientResponseDTO.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\dto\dashboard\ChartDataDTO.java =====
// path: business/src/main/java/com/securitybusinesssuite/business/dto/ChartDataDTO.java
package com.securitybusinesssuite.business.dto.dashboard;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;
import java.util.UUID;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ChartDataDTO {
    private String label;
    private BigDecimal value;
    private String color;
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\dto\dashboard\ChartDataDTO.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\dto\dashboard\DashboardStatsDTO.java =====
// path: business/src/main/java/com/securitybusinesssuite/business/dto/DashboardDTO.java
package com.securitybusinesssuite.business.dto.dashboard;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;
import java.util.UUID;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class DashboardStatsDTO {
    private long totalClients;
    private long activeClients;
    private long pendingInvoices;
    private long overdueInvoices;
    private BigDecimal totalPendingAmount;
    private BigDecimal totalOverdueAmount;
    private BigDecimal monthlyRevenue;
    private BigDecimal yearToDateRevenue;
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\dto\dashboard\DashboardStatsDTO.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\dto\dashboard\RecentActivityDTO.java =====
// path: business/src/main/java/com/securitybusinesssuite/business/dto/RecentActivityDTO.java
package com.securitybusinesssuite.business.dto.dashboard;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;
import java.util.UUID;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class RecentActivityDTO {
    private UUID id;
    private ActivityType type;
    private String description;
    private String clientName;
    private BigDecimal amount;
    private LocalDateTime timestamp;

    public enum ActivityType {
        CLIENT_CREATED, INVOICE_CREATED, PAYMENT_RECEIVED, INVOICE_OVERDUE
    }
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\dto\dashboard\RecentActivityDTO.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\dto\invoicerequest\CreateInvoiceRequestDTO.java =====
// path: business/src/main/java/com/securitybusinesssuite/business/dto/CreateInvoiceRequestDTO.java
package com.securitybusinesssuite.business.dto.invoicerequest;

import com.securitybusinesssuite.data.entity.Invoice;
import jakarta.validation.Valid;
import jakarta.validation.constraints.*;
import lombok.Data;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.List;
import java.util.UUID;

@Data
public class CreateInvoiceRequestDTO {
    @NotNull(message = "Client ID is required")
    private UUID clientId;

    @NotNull(message = "Issue date is required")
    private LocalDate issueDate;

    @NotNull(message = "Due date is required")
    @Future(message = "Due date must be in the future")
    private LocalDate dueDate;

    @NotNull(message = "Invoice type is required")
    private Invoice.InvoiceType invoiceType;

    @NotEmpty(message = "Invoice must have at least one item")
    @Valid
    private List<InvoiceItemRequestDTO> items;

    @DecimalMin(value = "0.0", message = "Discount amount cannot be negative")
    private BigDecimal discountAmount = BigDecimal.ZERO;

    private String notes;
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\dto\invoicerequest\CreateInvoiceRequestDTO.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\dto\invoicerequest\InvoiceItemRequestDTO.java =====
// path: business/src/main/java/com/securitybusinesssuite/business/dto/InvoiceItemRequestDTO.java
package com.securitybusinesssuite.business.dto.invoicerequest;

import com.securitybusinesssuite.data.entity.Client;
import com.securitybusinesssuite.data.entity.Invoice;
import jakarta.validation.Valid;
import jakarta.validation.constraints.*;
import lombok.Data;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.List;
import java.util.UUID;

@Data
public class InvoiceItemRequestDTO {
    private String serviceCode = "SF-0001";

    @NotBlank(message = "Description is required")
    private String description = "SERVICIO SEGURIDAD PRIVADA";

    private Client.SecurityService serviceType;

    @NotNull(message = "Quantity is required")
    @DecimalMin(value = "0.01", message = "Quantity must be positive")
    private BigDecimal quantity;

    @NotNull(message = "Unit price is required")
    @DecimalMin(value = "0.0", message = "Unit price cannot be negative")
    private BigDecimal unitPrice;

    @DecimalMin(value = "0.0", message = "Discount percentage cannot be negative")
    @DecimalMax(value = "100.0", message = "Discount percentage cannot exceed 100%")
    private BigDecimal discountPercentage = BigDecimal.ZERO;
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\dto\invoicerequest\InvoiceItemRequestDTO.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\dto\invoicerequest\UpdateInvoiceRequestDTO.java =====
package com.securitybusinesssuite.business.dto.invoicerequest;

import com.securitybusinesssuite.data.entity.Invoice;
import jakarta.validation.Valid;
import jakarta.validation.constraints.DecimalMin;
import jakarta.validation.constraints.NotNull;
import lombok.Data;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.List;

@Data
public class UpdateInvoiceRequestDTO {
    @NotNull(message = "Due date is required")
    private LocalDate dueDate;

    @NotNull(message = "Invoice type is required")
    private Invoice.InvoiceType invoiceType;

    @Valid
    private List<InvoiceItemRequestDTO> items;

    @DecimalMin(value = "0.0", message = "Discount amount cannot be negative")
    private BigDecimal discountAmount = BigDecimal.ZERO;

    private String notes;
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\dto\invoicerequest\UpdateInvoiceRequestDTO.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\dto\invoiceresponse\InvoiceItemResponseDTO.java =====
// path: business/src/main/java/com/securitybusinesssuite/business/dto/InvoiceItemResponseDTO.java
package com.securitybusinesssuite.business.dto.invoiceresponse;

import com.securitybusinesssuite.data.entity.Client;
import com.securitybusinesssuite.data.entity.InvoiceItem;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.util.UUID;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class InvoiceItemResponseDTO {
    private UUID id;
    private UUID invoiceId;
    private String serviceCode;
    private String description;
    private Client.SecurityService serviceType;
    private BigDecimal quantity;
    private BigDecimal unitPrice;
    private BigDecimal itbisRate;
    private BigDecimal itbisAmount;
    private BigDecimal discountPercentage;
    private BigDecimal discountAmount;
    private BigDecimal lineSubtotal;
    private BigDecimal lineTotal;

    public static InvoiceItemResponseDTO fromEntity(InvoiceItem item) {
        return InvoiceItemResponseDTO.builder()
                .id(item.getId())
                .invoiceId(item.getInvoiceId())
                .serviceCode(item.getServiceCode())
                .description(item.getDescription())
                .serviceType(item.getServiceType())
                .quantity(item.getQuantity())
                .unitPrice(item.getUnitPrice())
                .itbisRate(item.getItbisRate())
                .itbisAmount(item.getItbisAmount())
                .discountPercentage(item.getDiscountPercentage())
                .discountAmount(item.getDiscountAmount())
                .lineSubtotal(item.getLineSubtotal())
                .lineTotal(item.getLineTotal())
                .build();
    }
}

===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\dto\invoiceresponse\InvoiceItemResponseDTO.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\dto\invoiceresponse\InvoiceResponseDTO.java =====
// path: business/src/main/java/com/securitybusinesssuite/business/dto/InvoiceResponseDTO.java
package com.securitybusinesssuite.business.dto.invoiceresponse;

import com.securitybusinesssuite.business.dto.ClientResponseDTO;
import com.securitybusinesssuite.data.entity.Invoice;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.List;
import java.util.UUID;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class InvoiceResponseDTO {
    private UUID id;
    private String invoiceNumber;
    private String ncf;
    private Invoice.NCFType ncfType;
    private UUID clientId;
    private ClientResponseDTO client;
    private LocalDate issueDate;
    private LocalDate dueDate;
    private Invoice.InvoiceType invoiceType;
    private BigDecimal subtotal;
    private BigDecimal itbisAmount;
    private BigDecimal discountAmount;
    private BigDecimal totalAmount;
    private BigDecimal netAmount;
    private BigDecimal paidAmount;
    private BigDecimal balanceDue;
    private Invoice.InvoiceStatus status;
    private String notes;
    private List<InvoiceItemResponseDTO> items;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;

    public static InvoiceResponseDTO fromEntity(Invoice invoice) {
        return InvoiceResponseDTO.builder()
                .id(invoice.getId())
                .invoiceNumber(invoice.getInvoiceNumber())
                .ncf(invoice.getNcf())
                .ncfType(invoice.getNcfType())
                .clientId(invoice.getClientId())
                .client(invoice.getClient() != null ? ClientResponseDTO.fromEntity(invoice.getClient()) : null)
                .issueDate(invoice.getIssueDate())
                .dueDate(invoice.getDueDate())
                .invoiceType(invoice.getInvoiceType())
                .subtotal(invoice.getSubtotal())
                .itbisAmount(invoice.getItbisAmount())
                .discountAmount(invoice.getDiscountAmount())
                .totalAmount(invoice.getTotalAmount())
                .netAmount(invoice.getNetAmount())
                .paidAmount(invoice.getPaidAmount())
                .balanceDue(invoice.getBalanceDue())
                .status(invoice.getStatus())
                .notes(invoice.getNotes())
                .createdAt(invoice.getCreatedAt())
                .updatedAt(invoice.getUpdatedAt())
                .build();
    }
}

===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\dto\invoiceresponse\InvoiceResponseDTO.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\dto\LoginRequest.java =====
// path: business/src/main/java/com/securitybusinesssuite/business/dto/LoginRequest.java
package com.securitybusinesssuite.business.dto;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import lombok.Data;

@Data
public class LoginRequest {
    @Email(message = "Invalid email format")
    @NotBlank(message = "Email is required")
    private String email;

    @NotBlank(message = "Password is required")
    private String password;
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\dto\LoginRequest.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\dto\OAuthResult.java =====
// path: business/src/main/java/com/securitybusinesssuite/business/dto/OAuthResult.java
package com.securitybusinesssuite.business.dto;

import com.securitybusinesssuite.data.entity.User;

public class OAuthResult {
    private final User user;
    private final boolean isNewUser;

    public OAuthResult(User user, boolean isNewUser) {
        this.user = user;
        this.isNewUser = isNewUser;
    }

    public User getUser() {
        return user;
    }

    public boolean isNewUser() {
        return isNewUser;
    }
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\dto\OAuthResult.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\dto\receiptrequest\CreateReceiptRequestDTO.java =====
// path: business/src/main/java/com/securitybusinesssuite/business/dto/CreateReceiptRequestDTO.java
package com.securitybusinesssuite.business.dto.receiptrequest;

import com.securitybusinesssuite.data.entity.Client;
import jakarta.validation.Valid;
import jakarta.validation.constraints.*;
import lombok.Data;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.List;
import java.util.UUID;

@Data
public class CreateReceiptRequestDTO {
    @NotNull(message = "Client ID is required")
    private UUID clientId;

    @NotNull(message = "Issue date is required")
    private LocalDate issueDate;

    @NotNull(message = "Total amount is required")
    @DecimalMin(value = "0.01", message = "Total amount must be positive")
    private BigDecimal totalAmount;

    @NotNull(message = "Payment method is required")
    private Client.PaymentMethod paymentMethod;

    private String currency = "DOP";

    // Payment method specific fields
    private String checkNumber;
    private String bankName;
    private String referenceNumber;

    private String notes;

    @Valid
    private List<PaymentAllocationDTO> allocations;
}

===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\dto\receiptrequest\CreateReceiptRequestDTO.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\dto\receiptrequest\PaymentAllocationDTO.java =====
// path: business/src/main/java/com/securitybusinesssuite/business/dto/PaymentAllocationDTO.java
package com.securitybusinesssuite.business.dto.receiptrequest;

import com.securitybusinesssuite.data.entity.Client;
import jakarta.validation.Valid;
import jakarta.validation.constraints.*;
import lombok.Data;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.List;
import java.util.UUID;

@Data
public class PaymentAllocationDTO {
    @NotNull(message = "Invoice ID is required")
    private UUID invoiceId;

    @NotNull(message = "Allocated amount is required")
    @DecimalMin(value = "0.01", message = "Allocated amount must be positive")
    private BigDecimal allocatedAmount;
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\dto\receiptrequest\PaymentAllocationDTO.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\dto\receiptrequest\UpdateReceiptRequestDTO.java =====
// path: business/src/main/java/com/securitybusinesssuite/business/dto/receiptrequest/UpdateReceiptRequestDTO.java
package com.securitybusinesssuite.business.dto.receiptrequest;

import com.securitybusinesssuite.data.entity.Client;
import com.securitybusinesssuite.data.entity.Receipt;
import jakarta.validation.Valid;
import jakarta.validation.constraints.*;
import lombok.Data;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.List;
import java.util.UUID;

@Data
public class UpdateReceiptRequestDTO {
    @NotNull(message = "Issue date is required")
    private LocalDate issueDate;

    @NotNull(message = "Total amount is required")
    @DecimalMin(value = "0.01", message = "Total amount must be positive")
    private BigDecimal totalAmount;

    @NotNull(message = "Payment method is required")
    private Client.PaymentMethod paymentMethod;

    private String currency = "DOP";

    // Payment method specific fields
    private String checkNumber;
    private String bankName;
    private String referenceNumber;

    @NotNull(message = "Status is required")
    private Receipt.ReceiptStatus status;

    private String notes;
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\dto\receiptrequest\UpdateReceiptRequestDTO.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\dto\receiptresponse\ReceiptAllocationResponseDTO.java =====
// path: business/src/main/java/com/securitybusinesssuite/business/dto/ReceiptAllocationResponseDTO.java
package com.securitybusinesssuite.business.dto.receiptresponse;

import com.securitybusinesssuite.business.dto.invoiceresponse.InvoiceResponseDTO;
import com.securitybusinesssuite.data.entity.ReceiptAllocation;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.UUID;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ReceiptAllocationResponseDTO {
    private UUID id;
    private UUID receiptId;
    private UUID invoiceId;
    private InvoiceResponseDTO invoice;
    private BigDecimal allocatedAmount;
    private LocalDateTime createdAt;

    public static ReceiptAllocationResponseDTO fromEntity(ReceiptAllocation allocation) {
        return ReceiptAllocationResponseDTO.builder()
                .id(allocation.getId())
                .receiptId(allocation.getReceiptId())
                .invoiceId(allocation.getInvoiceId())
                .invoice(allocation.getInvoice() != null ? InvoiceResponseDTO.fromEntity(allocation.getInvoice()) : null)
                .allocatedAmount(allocation.getAllocatedAmount())
                .createdAt(allocation.getCreatedAt())
                .build();
    }
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\dto\receiptresponse\ReceiptAllocationResponseDTO.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\dto\receiptresponse\ReceiptResponseDTO.java =====
// path: business/src/main/java/com/securitybusinesssuite/business/dto/ReceiptResponseDTO.java
package com.securitybusinesssuite.business.dto.receiptresponse;

import com.securitybusinesssuite.business.dto.ClientResponseDTO;
import com.securitybusinesssuite.data.entity.Client;
import com.securitybusinesssuite.data.entity.Receipt;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.List;
import java.util.UUID;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ReceiptResponseDTO {
    private UUID id;
    private String receiptNumber;
    private UUID clientId;
    private ClientResponseDTO client;
    private LocalDate issueDate;
    private BigDecimal totalAmount;
    private Client.PaymentMethod paymentMethod;
    private String currency;
    private String checkNumber;
    private String bankName;
    private String referenceNumber;
    private Receipt.ReceiptStatus status;
    private String notes;
    private List<ReceiptAllocationResponseDTO> allocations;
    private BigDecimal allocatedAmount;
    private BigDecimal availableAmount;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;

    public static ReceiptResponseDTO fromEntity(Receipt receipt) {
        return ReceiptResponseDTO.builder()
                .id(receipt.getId())
                .receiptNumber(receipt.getReceiptNumber())
                .clientId(receipt.getClientId())
                .client(receipt.getClient() != null ? ClientResponseDTO.fromEntity(receipt.getClient()) : null)
                .issueDate(receipt.getIssueDate())
                .totalAmount(receipt.getTotalAmount())
                .paymentMethod(receipt.getPaymentMethod())
                .currency(receipt.getCurrency())
                .checkNumber(receipt.getCheckNumber())
                .bankName(receipt.getBankName())
                .referenceNumber(receipt.getReferenceNumber())
                .status(receipt.getStatus())
                .notes(receipt.getNotes())
                .createdAt(receipt.getCreatedAt())
                .updatedAt(receipt.getUpdatedAt())
                .build();
    }
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\dto\receiptresponse\ReceiptResponseDTO.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\dto\RegisterRequest.java =====
// path: business/src/main/java/com/securitybusinesssuite/business/dto/RegisterRequest.java
package com.securitybusinesssuite.business.dto;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.Data;

@Data
public class RegisterRequest {
    @Email(message = "Invalid email format")
    @NotBlank(message = "Email is required")
    private String email;

    @NotBlank(message = "Password is required")
    @Size(min = 8, message = "Password must be at least 8 characters")
    private String password;

    @NotBlank(message = "First name is required")
    private String firstName;

    @NotBlank(message = "Last name is required")
    private String lastName;
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\dto\RegisterRequest.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\dto\search\ClientSearchCriteria.java =====
// path: business/src/main/java/com/securitybusinesssuite/business/dto/searchDTO/ClientSearchCriteria.java
package com.securitybusinesssuite.business.dto.search;

import com.securitybusinesssuite.data.entity.Client;
import lombok.Data;

@Data
public class ClientSearchCriteria {
    private String businessName;
    private Client.ClientType clientType;
    private Client.ClientStatus status;
    private Client.BusinessSector businessSector;
    private String rnc;
    private int page = 0;
    private int size = 20;
    private String sortBy = "createdAt";
    private String sortDirection = "DESC";
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\dto\search\ClientSearchCriteria.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\dto\search\InvoiceSearchCriteria.java =====
// path: business/src/main/java/com/securitybusinesssuite/business/dto/searchDTO/InvoiceSearchCriteria.java
package com.securitybusinesssuite.business.dto.search;

import com.securitybusinesssuite.data.entity.Invoice;
import lombok.Data;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.UUID;
@Data
public class InvoiceSearchCriteria {
    private UUID clientId;
    private String clientName;
    private Invoice.InvoiceStatus status;
    private LocalDate fromDate;
    private LocalDate toDate;
    private BigDecimal minAmount;
    private BigDecimal maxAmount;
    private String invoiceNumber;
    private String ncf;
    private int page = 0;
    private int size = 20;
    private String sortBy = "createdAt";
    private String sortDirection = "DESC";
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\dto\search\InvoiceSearchCriteria.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\dto\search\PagedResponseDTO.java =====
// path: business/src/main/java/com/securitybusinesssuite/business/dto/searchDTO/PagedResponseDTO.java
package com.securitybusinesssuite.business.dto.search;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class PagedResponseDTO<T> {
    private List<T> content;
    private int page;
    private int size;
    private long totalElements;
    private int totalPages;
    private boolean first;
    private boolean last;
    private boolean hasNext;
    private boolean hasPrevious;
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\dto\search\PagedResponseDTO.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\dto\search\ReceiptSearchCriteria.java =====
// path: business/src/main/java/com/securitybusinesssuite/business/dto/searchDTO/ReceiptSearchCriteria.java
package com.securitybusinesssuite.business.dto.search;

import com.securitybusinesssuite.data.entity.Client;
import com.securitybusinesssuite.data.entity.Receipt;
import lombok.Data;

import java.time.LocalDate;
import java.util.UUID;
@Data
public class ReceiptSearchCriteria {
    private UUID clientId;
    private String clientName;
    private Receipt.ReceiptStatus status;
    private LocalDate fromDate;
    private LocalDate toDate;
    private Client.PaymentMethod paymentMethod;
    private String receiptNumber;
    private int page = 0;
    private int size = 20;
    private String sortBy = "createdAt";
    private String sortDirection = "DESC";
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\dto\search\ReceiptSearchCriteria.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\dto\TokenPair.java =====
// path: business/src/main/java/com/securitybusinesssuite/business/dto/TokenPair.java
package com.securitybusinesssuite.business.dto;

import lombok.AllArgsConstructor;
import lombok.Data;

@Data
@AllArgsConstructor
public class TokenPair {
    private String accessToken;
    private String refreshToken;
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\dto\TokenPair.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\dto\UserDto.java =====
// path: business/src/main/java/com/securitybusinesssuite/business/dto/UserDto.java
package com.securitybusinesssuite.business.dto;

import com.securitybusinesssuite.data.entity.User;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;
import java.util.UUID;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class UserDto {
    private UUID id;
    private String email;
    private String firstName;
    private String lastName;
    private boolean emailVerified;
    private User.AuthProvider provider;
    private LocalDateTime createdAt;

    public static UserDto fromEntity(User user) {
        return UserDto.builder()
                .id(user.getId())
                .email(user.getEmail())
                .firstName(user.getFirstName())
                .lastName(user.getLastName())
                .emailVerified(user.isEmailVerified())
                .provider(user.getProvider())
                .createdAt(user.getCreatedAt())
                .build();
    }
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\dto\UserDto.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\exception\AuthenticationException.java =====
// path: business/src/main/java/com/securitybusinesssuite/business/exception/AuthenticationException.java
package com.securitybusinesssuite.business.exception;

public class AuthenticationException extends BusinessException {
    public AuthenticationException(String message) {
        super(message);
    }
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\exception\AuthenticationException.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\exception\BusinessException.java =====
// path: business/src/main/java/com/securitybusinesssuite/business/exception/BusinessException.java
package com.securitybusinesssuite.business.exception;

public class BusinessException extends RuntimeException {
    public BusinessException(String message) {
        super(message);
    }

    public BusinessException(String message, Throwable cause) {
        super(message, cause);
    }
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\exception\BusinessException.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\exception\BusinessValidationException.java =====
// path: business/src/main/java/com/securitybusinesssuite/business/exception/BusinessValidationException.java
package com.securitybusinesssuite.business.exception;

public class BusinessValidationException extends BusinessException {
    public BusinessValidationException(String message) {
        super(message);
    }
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\exception\BusinessValidationException.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\exception\ClientNotFoundException.java =====
// path: business/src/main/java/com/securitybusinesssuite/business/exception/ClientNotFoundException.java
package com.securitybusinesssuite.business.exception;

public class ClientNotFoundException extends BusinessException {
    public ClientNotFoundException(String message) {
        super(message);
    }
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\exception\ClientNotFoundException.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\exception\InvalidPaymentAllocationException.java =====
// path: business/src/main/java/com/securitybusinesssuite/business/exception/InvalidPaymentAllocationException.java
package com.securitybusinesssuite.business.exception;

public class InvalidPaymentAllocationException extends BusinessException {
    public InvalidPaymentAllocationException(String message) {
        super(message);
    }
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\exception\InvalidPaymentAllocationException.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\exception\InvalidRNCException.java =====
// path: business/src/main/java/com/securitybusinesssuite/business/exception/InvalidRNCException.java
package com.securitybusinesssuite.business.exception;

public class InvalidRNCException extends BusinessException {
    public InvalidRNCException(String message) {
        super(message);
    }
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\exception\InvalidRNCException.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\exception\InvoiceNotFoundException.java =====
// path: business/src/main/java/com/securitybusinesssuite/business/exception/InvoiceNotFoundException.java
package com.securitybusinesssuite.business.exception;

public class InvoiceNotFoundException extends BusinessException {
    public InvoiceNotFoundException(String message) {
        super(message);
    }
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\exception\InvoiceNotFoundException.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\exception\NCFSequenceExhaustedException.java =====
// path: business/src/main/java/com/securitybusinesssuite/business/exception/NCFSequenceExhaustedException.java
package com.securitybusinesssuite.business.exception;

public class NCFSequenceExhaustedException extends BusinessException {
    public NCFSequenceExhaustedException(String message) {
        super(message);
    }
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\exception\NCFSequenceExhaustedException.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\exception\ReceiptNotFoundException.java =====
// path: business/src/main/java/com/securitybusinesssuite/business/exception/ReceiptNotFoundException.java
package com.securitybusinesssuite.business.exception;

public class ReceiptNotFoundException extends BusinessException {
    public ReceiptNotFoundException(String message) {
        super(message);
    }
}

===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\exception\ReceiptNotFoundException.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\exception\UserAlreadyExistsException.java =====
// path: business/src/main/java/com/securitybusinesssuite/business/exception/UserAlreadyExistsException.java
package com.securitybusinesssuite.business.exception;

public class UserAlreadyExistsException extends BusinessException {
    public UserAlreadyExistsException(String message) {
        super(message);
    }
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\exception\UserAlreadyExistsException.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\service\AuthService.java =====
// path: business/src/main/java/com/securitybusinesssuite/business/service/AuthService.java
package com.securitybusinesssuite.business.service;

import com.securitybusinesssuite.business.dto.*;
import com.securitybusinesssuite.data.entity.User;

import java.util.Map;

public interface AuthService {
    AuthResponse register(RegisterRequest request);
    TokenPair login(LoginRequest request);
    String verifyEmail(String token);
    TokenPair refresh(String refreshToken);
    OAuthResult processOAuthLogin(String email, String provider, String providerId, Map<String, Object> attributes);
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\service\AuthService.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\service\CalculationService.java =====
// path: business/src/main/java/com/securitybusinesssuite/business/service/CalculationService.java
package com.securitybusinesssuite.business.service;

import com.securitybusinesssuite.data.entity.Invoice;
import com.securitybusinesssuite.data.entity.InvoiceItem;
import java.math.BigDecimal;
import java.util.List;

public interface CalculationService {
    Invoice calculateInvoiceTotals(Invoice invoice, List<InvoiceItem> items);
    InvoiceItem calculateLineItem(InvoiceItem item);
    BigDecimal calculateITBIS(BigDecimal taxableAmount);
    BigDecimal calculateLineSubtotal(BigDecimal quantity, BigDecimal unitPrice);
    BigDecimal calculateLineDiscount(BigDecimal subtotal, BigDecimal discountPercentage);
    BigDecimal calculateLineTotal(BigDecimal subtotal, BigDecimal itbisAmount, BigDecimal discountAmount);
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\service\CalculationService.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\service\ClientService.java =====
// path: business/src/main/java/com/securitybusinesssuite/business/service/ClientService.java
package com.securitybusinesssuite.business.service;

import com.securitybusinesssuite.business.dto.*;
import com.securitybusinesssuite.business.dto.clientrequest.CreateClientRequestDTO;
import com.securitybusinesssuite.business.dto.clientrequest.UpdateClientRequestDTO;
import com.securitybusinesssuite.business.dto.search.ClientSearchCriteria;
import com.securitybusinesssuite.business.dto.search.PagedResponseDTO;
import org.springframework.data.domain.Pageable;
import java.util.UUID;

public interface ClientService {
    ClientResponseDTO createClient(CreateClientRequestDTO request, UUID createdBy);
    ClientResponseDTO updateClient(UUID id, UpdateClientRequestDTO request, UUID updatedBy);
    ClientResponseDTO getClient(UUID id);
    PagedResponseDTO<ClientResponseDTO> searchClients(ClientSearchCriteria criteria);
    void deleteClient(UUID id);
    boolean existsByRnc(String rnc);
    String generateClientCode();
    void validateClientData(CreateClientRequestDTO request);
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\service\ClientService.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\service\DashboardService.java =====
// path: business/src/main/java/com/securitybusinesssuite/business/service/DashboardService.java
package com.securitybusinesssuite.business.service;

import com.securitybusinesssuite.business.dto.*;
import com.securitybusinesssuite.business.dto.dashboard.ChartDataDTO;
import com.securitybusinesssuite.business.dto.dashboard.DashboardStatsDTO;
import com.securitybusinesssuite.business.dto.dashboard.RecentActivityDTO;

import java.util.List;

public interface DashboardService {
    DashboardStatsDTO getDashboardStats();
    List<RecentActivityDTO> getRecentActivity();
    List<ChartDataDTO> getInvoicesByStatusChart();
    List<ChartDataDTO> getRevenueByMonthChart();
    List<ChartDataDTO> getClientsByTypeChart();
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\service\DashboardService.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\service\EmailService.java =====
// path: business/src/main/java/com/securitybusinesssuite/business/service/EmailService.java
package com.securitybusinesssuite.business.service;

public interface EmailService {
    void sendVerificationEmail(String to, String firstName, String verificationToken);
    void sendPasswordResetEmail(String to, String firstName, String resetToken);
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\service\EmailService.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\service\impl\AuthServiceImpl.java =====
// path: business/src/main/java/com/securitybusinesssuite/business/service/impl/AuthServiceImpl.java
package com.securitybusinesssuite.business.service.impl;

import com.securitybusinesssuite.business.dto.*;
import com.securitybusinesssuite.business.exception.AuthenticationException;
import com.securitybusinesssuite.business.exception.BusinessException;
import com.securitybusinesssuite.business.exception.UserAlreadyExistsException;
import com.securitybusinesssuite.business.service.AuthService;
import com.securitybusinesssuite.business.service.EmailService;
import com.securitybusinesssuite.business.service.JwtService;
import com.securitybusinesssuite.data.entity.User;
import com.securitybusinesssuite.data.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.Map;
import java.util.Optional;
import java.util.UUID;

@Slf4j
@Service
@RequiredArgsConstructor
public class AuthServiceImpl implements AuthService {

    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;
    private final JwtService jwtService;
    private final EmailService emailService;

    @Override
    @Transactional
    public AuthResponse register(RegisterRequest request) {
        // Check if user exists
        Optional<User> existingUser = userRepository.findByEmail(request.getEmail());

        if (existingUser.isPresent()) {
            User user = existingUser.get();

            // If email is already verified, user is fully registered
            if (user.isEmailVerified()) {
                throw new UserAlreadyExistsException("Email already registered and verified");
            }

            // If email not verified, resend verification email
            if (!user.isEmailVerified()) {
                // Generate new verification token
                String newVerificationToken = UUID.randomUUID().toString();
                user.setEmailVerificationToken(newVerificationToken);
                user.setEmailVerificationTokenExpiry(LocalDateTime.now().plusHours(24));
                User updatedUser = userRepository.update(user);

                // Resend verification email
                emailService.sendVerificationEmail(
                        user.getEmail(),
                        user.getFirstName(),
                        newVerificationToken
                );

                return AuthResponse.builder().message("Verification email resent. Please check your email.")
                        .user(UserDto.fromEntity(updatedUser))
                        .requiresEmailVerification(true)
                        .build();
            }
        }

        // Create new user
        String verificationToken = UUID.randomUUID().toString();
        User user = User.builder()
                .email(request.getEmail())
                .passwordHash(passwordEncoder.encode(request.getPassword()))
                .firstName(request.getFirstName())
                .lastName(request.getLastName())
                .emailVerified(false)
                .provider(User.AuthProvider.LOCAL)
                .emailVerificationToken(verificationToken)
                .emailVerificationTokenExpiry(LocalDateTime.now().plusHours(24))
                .build();

        User savedUser = userRepository.save(user);

        // Send verification email
        emailService.sendVerificationEmail(
                savedUser.getEmail(),
                savedUser.getFirstName(),
                verificationToken
        );

        return AuthResponse.builder()
                .message("Registration successful. Please check your email to verify your account.")
                .user(UserDto.fromEntity(savedUser))
                .requiresEmailVerification(true)
                .build();
    }

    @Override
    public TokenPair login(LoginRequest request) {
        User user = userRepository.findByEmail(request.getEmail())
                .orElseThrow(() -> new AuthenticationException("Invalid email or password"));

        // Check if OAuth user trying to login with password
        if (user.getProvider() != User.AuthProvider.LOCAL) {
            throw new AuthenticationException("Please login with " + user.getProvider());
        }

        // Verify password
        if (!passwordEncoder.matches(request.getPassword(), user.getPasswordHash())) {
            throw new AuthenticationException("Invalid email or password");
        }

        // Check email verification
        if (!user.isEmailVerified()) {
            throw new AuthenticationException("Please verify your email before logging in");
        }

        return jwtService.generateTokenPair(user.getId(), user.getEmail());
    }

    @Override
    @Transactional
    public String verifyEmail(String token) {
        User user = userRepository.findByEmailVerificationToken(token)
                .orElseThrow(() -> new BusinessException("Invalid verification token"));

        if (user.getEmailVerificationTokenExpiry().isBefore(LocalDateTime.now())) {
            throw new BusinessException("Verification token has expired");
        }

        if (user.isEmailVerified()) {
            throw new BusinessException("Email already verified");
        }

        user.setEmailVerified(true);
        user.setEmailVerificationToken(null);
        user.setEmailVerificationTokenExpiry(null);
        userRepository.update(user);

        log.info("Email verified for user: {}", user.getEmail());
        return user.getEmail();
    }

    @Override
    public TokenPair refresh(String refreshToken) {
        if (!jwtService.validateToken(refreshToken)) {
            throw new AuthenticationException("Invalid refresh token");
        }

        String tokenType = jwtService.getTokenType(refreshToken);
        if (!"refresh".equals(tokenType)) {
            throw new AuthenticationException("Invalid token type");
        }

        UUID userId = jwtService.getUserIdFromToken(refreshToken);
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new AuthenticationException("User not found"));

        return jwtService.generateTokenPair(user.getId(), user.getEmail());
    }

    @Override
    @Transactional
    public OAuthResult processOAuthLogin(String email, String provider, String providerId, Map<String, Object> attributes) {
        User.AuthProvider authProvider = User.AuthProvider.valueOf(provider.toUpperCase());

        // Check if OAuth user exists
        Optional<User> existingOAuthUser = userRepository.findByProviderAndProviderId(authProvider, providerId);
        if (existingOAuthUser.isPresent()) {
            log.info("OAuth user found, logging in: {}", email);
            return new OAuthResult(existingOAuthUser.get(), false); // Existing user
        }

        // Check if email exists (link accounts)
        Optional<User> existingEmailUser = userRepository.findByEmail(email);
        if (existingEmailUser.isPresent()) {
            User user = existingEmailUser.get();

            // Update to OAuth provider
            user.setProvider(authProvider);
            user.setProviderId(providerId);
            user.setEmailVerified(true);

            // Update name if not set
            if (user.getFirstName() == null && attributes.containsKey("given_name")) {
                user.setFirstName((String) attributes.get("given_name"));
            }
            if (user.getLastName() == null && attributes.containsKey("family_name")) {
                user.setLastName((String) attributes.get("family_name"));
            }

            User updatedUser = userRepository.update(user);
            log.info("Linked OAuth to existing account: {}", email);
            return new OAuthResult(updatedUser, false); // Existing user (linked)
        }

        // Create new OAuth user
        String firstName = (String) attributes.get("given_name");
        String lastName = (String) attributes.get("family_name");

        User newUser = User.builder()
                .email(email)
                .firstName(firstName != null ? firstName : "OAuth")
                .lastName(lastName != null ? lastName : "User")
                .emailVerified(true)
                .provider(authProvider)
                .providerId(providerId)
                .build();

        User savedUser = userRepository.save(newUser);
        log.info("Created new OAuth user: {}", email);
        return new OAuthResult(savedUser, true); // New user
    }

}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\service\impl\AuthServiceImpl.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\service\impl\CalculationServiceImpl.java =====
// path: business/src/main/java/com/securitybusinesssuite/business/service/impl/CalculationServiceImpl.java
package com.securitybusinesssuite.business.service.impl;

import com.securitybusinesssuite.business.config.DominicanTaxConfig;
import com.securitybusinesssuite.business.service.CalculationService;
import com.securitybusinesssuite.data.entity.Invoice;
import com.securitybusinesssuite.data.entity.InvoiceItem;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.util.List;

@Service
@RequiredArgsConstructor
public class CalculationServiceImpl implements CalculationService {

    private final DominicanTaxConfig taxConfig;

    @Override
    public Invoice calculateInvoiceTotals(Invoice invoice, List<InvoiceItem> items) {
        BigDecimal subtotal = BigDecimal.ZERO;
        BigDecimal totalItbis = BigDecimal.ZERO;
        BigDecimal totalDiscounts = BigDecimal.ZERO;

        // Calculate totals from line items
        for (InvoiceItem item : items) {
            InvoiceItem calculatedItem = calculateLineItem(item);

            subtotal = subtotal.add(calculatedItem.getLineSubtotal());
            totalItbis = totalItbis.add(calculatedItem.getItbisAmount());
            totalDiscounts = totalDiscounts.add(calculatedItem.getDiscountAmount());
        }

        // Apply invoice-level discount if any
        if (invoice.getDiscountAmount() != null && invoice.getDiscountAmount().compareTo(BigDecimal.ZERO) > 0) {
            totalDiscounts = totalDiscounts.add(invoice.getDiscountAmount());
        }

        // Calculate final amounts
        BigDecimal netAmount = subtotal.subtract(totalDiscounts);
        BigDecimal totalAmount = netAmount.add(totalItbis);
        BigDecimal balanceDue = totalAmount.subtract(invoice.getPaidAmount() != null ? invoice.getPaidAmount() : BigDecimal.ZERO);

        // Set calculated values
        invoice.setSubtotal(subtotal);
        invoice.setItbisAmount(totalItbis);
        invoice.setDiscountAmount(totalDiscounts);
        invoice.setNetAmount(netAmount);
        invoice.setTotalAmount(totalAmount);
        invoice.setBalanceDue(balanceDue);

        return invoice;
    }

    @Override
    public InvoiceItem calculateLineItem(InvoiceItem item) {
        // Calculate line subtotal
        BigDecimal lineSubtotal = calculateLineSubtotal(item.getQuantity(), item.getUnitPrice());

        // Calculate discount amount
        BigDecimal discountAmount = calculateLineDiscount(lineSubtotal,
                item.getDiscountPercentage() != null ? item.getDiscountPercentage() : BigDecimal.ZERO);

        // Calculate taxable amount (subtotal minus discount)
        BigDecimal taxableAmount = lineSubtotal.subtract(discountAmount);

        // Calculate ITBIS
        BigDecimal itbisAmount = calculateITBIS(taxableAmount);

        // Calculate line total
        BigDecimal lineTotal = calculateLineTotal(lineSubtotal, itbisAmount, discountAmount);

        // Set calculated values
        item.setLineSubtotal(lineSubtotal);
        item.setDiscountAmount(discountAmount);
        item.setItbisRate(taxConfig.getItbisRate());
        item.setItbisAmount(itbisAmount);
        item.setLineTotal(lineTotal);

        return item;
    }

    @Override
    public BigDecimal calculateITBIS(BigDecimal taxableAmount) {
        if (taxableAmount == null || taxableAmount.compareTo(BigDecimal.ZERO) <= 0) {
            return BigDecimal.ZERO;
        }

        return taxableAmount.multiply(taxConfig.getItbisRate())
                .setScale(2, RoundingMode.HALF_UP);
    }

    @Override
    public BigDecimal calculateLineSubtotal(BigDecimal quantity, BigDecimal unitPrice) {
        if (quantity == null || unitPrice == null) {
            return BigDecimal.ZERO;
        }

        return quantity.multiply(unitPrice).setScale(2, RoundingMode.HALF_UP);
    }

    @Override
    public BigDecimal calculateLineDiscount(BigDecimal subtotal, BigDecimal discountPercentage) {
        if (subtotal == null || discountPercentage == null || discountPercentage.compareTo(BigDecimal.ZERO) <= 0) {
            return BigDecimal.ZERO;
        }

        return subtotal.multiply(discountPercentage.divide(BigDecimal.valueOf(100), 4, RoundingMode.HALF_UP))
                .setScale(2, RoundingMode.HALF_UP);
    }

    @Override
    public BigDecimal calculateLineTotal(BigDecimal subtotal, BigDecimal itbisAmount, BigDecimal discountAmount) {
        if (subtotal == null) subtotal = BigDecimal.ZERO;
        if (itbisAmount == null) itbisAmount = BigDecimal.ZERO;
        if (discountAmount == null) discountAmount = BigDecimal.ZERO;

        return subtotal.add(itbisAmount).subtract(discountAmount).setScale(2, RoundingMode.HALF_UP);
    }
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\service\impl\CalculationServiceImpl.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\service\impl\ClientServiceImpl.java =====
// path: business/src/main/java/com/securitybusinesssuite/business/service/impl/ClientServiceImpl.java
package com.securitybusinesssuite.business.service.impl;

import com.securitybusinesssuite.business.dto.*;
import com.securitybusinesssuite.business.dto.clientrequest.CreateClientRequestDTO;
import com.securitybusinesssuite.business.dto.clientrequest.UpdateClientRequestDTO;
import com.securitybusinesssuite.business.dto.search.ClientSearchCriteria;
import com.securitybusinesssuite.business.dto.search.PagedResponseDTO;
import com.securitybusinesssuite.business.exception.BusinessException;
import com.securitybusinesssuite.business.service.ClientService;
import com.securitybusinesssuite.business.service.ValidationService;
import com.securitybusinesssuite.data.entity.Client;
import com.securitybusinesssuite.data.entity.ClientSequence;
import com.securitybusinesssuite.data.repository.ClientRepository;
import com.securitybusinesssuite.data.repository.SequenceRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.UUID;
import java.util.stream.Collectors;

@Slf4j
@Service
@RequiredArgsConstructor
public class ClientServiceImpl implements ClientService {

    private final ClientRepository clientRepository;
    private final SequenceRepository sequenceRepository;
    private final ValidationService validationService;

    @Override
    @Transactional
    public ClientResponseDTO createClient(CreateClientRequestDTO request, UUID createdBy) {
        // Validate request
        validateClientData(request);

        // Check if RNC already exists
        if (request.getRnc() != null && !request.getRnc().trim().isEmpty()) {
            if (clientRepository.existsByRnc(request.getRnc())) {
                throw new BusinessException("A client with this RNC already exists");
            }
        }

        // Generate client code
        String clientCode = generateClientCode();

        // Create client entity
        Client client = Client.builder()
                .clientCode(clientCode)
                .rnc(request.getRnc())
                .clientType(request.getClientType())
                .businessName(request.getBusinessName())
                .contactPerson(request.getContactPerson())
                .businessSector(request.getBusinessSector())
                .phone(request.getPhone())
                .email(request.getEmail())
                .streetName(request.getStreetName())
                .streetNumber(request.getStreetNumber())
                .sector(request.getSector())
                .provincia(request.getProvincia())
                .services(request.getServices())
                .hasContract(request.isHasContract())
                .contractStartDate(request.getContractStartDate())
                .contractEndDate(request.getContractEndDate())
                .autoRenewal(request.isAutoRenewal())
                .paymentMethod(request.getPaymentMethod())
                .hourlyRate(request.getHourlyRate())
                .notes(request.getNotes())
                .status(Client.ClientStatus.ACTIVE)
                .createdBy(createdBy)
                .build();

        // Set business rules based on client type
        setClientBusinessRules(client);

        // Validate client business rules
        validationService.validateClientRequirements(client);

        // Save client
        Client savedClient = clientRepository.save(client);

        log.info("Client created: {} - {}", savedClient.getClientCode(), savedClient.getBusinessName());
        return ClientResponseDTO.fromEntity(savedClient);
    }

    @Override
    @Transactional
    public ClientResponseDTO updateClient(UUID id, UpdateClientRequestDTO request, UUID updatedBy) {
        Client existingClient = clientRepository.findById(id)
                .orElseThrow(() -> new BusinessException("Client not found"));

        // Check if RNC is changing and new RNC already exists
        if (request.getRnc() != null && !request.getRnc().equals(existingClient.getRnc())) {
            if (clientRepository.existsByRnc(request.getRnc())) {
                throw new BusinessException("A client with this RNC already exists");
            }
        }

        // Update client fields
        existingClient.setRnc(request.getRnc());
        existingClient.setClientType(request.getClientType());
        existingClient.setBusinessName(request.getBusinessName());
        existingClient.setContactPerson(request.getContactPerson());
        existingClient.setBusinessSector(request.getBusinessSector());
        existingClient.setPhone(request.getPhone());
        existingClient.setEmail(request.getEmail());
        existingClient.setStreetName(request.getStreetName());
        existingClient.setStreetNumber(request.getStreetNumber());
        existingClient.setSector(request.getSector());
        existingClient.setProvincia(request.getProvincia());
        existingClient.setServices(request.getServices());
        existingClient.setHasContract(request.isHasContract());
        existingClient.setContractStartDate(request.getContractStartDate());
        existingClient.setContractEndDate(request.getContractEndDate());
        existingClient.setAutoRenewal(request.isAutoRenewal());
        existingClient.setPaymentMethod(request.getPaymentMethod());
        existingClient.setHourlyRate(request.getHourlyRate());
        existingClient.setStatus(request.getStatus());
        existingClient.setNotes(request.getNotes());
        existingClient.setUpdatedBy(updatedBy);

        // Update business rules based on client type
        setClientBusinessRules(existingClient);

        // Validate client business rules
        validationService.validateClientRequirements(existingClient);

        // Update client
        Client updatedClient = clientRepository.update(existingClient);

        log.info("Client updated: {} - {}", updatedClient.getClientCode(), updatedClient.getBusinessName());
        return ClientResponseDTO.fromEntity(updatedClient);
    }

    @Override
    public ClientResponseDTO getClient(UUID id) {
        Client client = clientRepository.findById(id)
                .orElseThrow(() -> new BusinessException("Client not found"));
        return ClientResponseDTO.fromEntity(client);
    }

    @Override
    public PagedResponseDTO<ClientResponseDTO> searchClients(ClientSearchCriteria criteria) {
        // Create sort
        Sort.Direction direction = "ASC".equalsIgnoreCase(criteria.getSortDirection()) ?
                Sort.Direction.ASC : Sort.Direction.DESC;
        Sort sort = Sort.by(direction, criteria.getSortBy());

        // Create pageable
        Pageable pageable = PageRequest.of(criteria.getPage(), criteria.getSize(), sort);

        // Execute search
        Page<Client> clientPage = clientRepository.findByFilters(
                criteria.getBusinessName(),
                criteria.getClientType(),
                criteria.getStatus(),
                criteria.getBusinessSector(),
                pageable
        );

        // Convert to DTOs
        return PagedResponseDTO.<ClientResponseDTO>builder()
                .content(clientPage.getContent().stream()
                        .map(ClientResponseDTO::fromEntity)
                        .collect(Collectors.toList()))
                .page(clientPage.getNumber())
                .size(clientPage.getSize())
                .totalElements(clientPage.getTotalElements())
                .totalPages(clientPage.getTotalPages())
                .first(clientPage.isFirst())
                .last(clientPage.isLast())
                .hasNext(clientPage.hasNext())
                .hasPrevious(clientPage.hasPrevious())
                .build();
    }

    @Override
    @Transactional
    public void deleteClient(UUID id) {
        if (!clientRepository.findById(id).isPresent()) {
            throw new BusinessException("Client not found");
        }

        // TODO: Add business logic to check if client has active invoices/contracts
        // For now, we'll just delete
        clientRepository.deleteById(id);
        log.info("Client deleted: {}", id);
    }

    @Override
    public boolean existsByRnc(String rnc) {
        return clientRepository.existsByRnc(rnc);
    }

    @Override
    @Transactional
    public String generateClientCode() {
        int currentYear = LocalDate.now().getYear();

        ClientSequence sequence = sequenceRepository.findClientSequenceByYear(currentYear)
                .orElseGet(() -> {
                    // Create new sequence for current year
                    ClientSequence newSequence = ClientSequence.builder()
                            .currentNumber(0)
                            .prefix("I")
                            .year(currentYear)
                            .build();
                    return sequenceRepository.saveClientSequence(newSequence);
                });

        // Increment sequence
        sequence.setCurrentNumber(sequence.getCurrentNumber() + 1);
        sequenceRepository.updateClientSequence(sequence);

        // Format: I-0001, I-0002, etc.
        return String.format("%s-%04d", sequence.getPrefix(), sequence.getCurrentNumber());
    }

    @Override
    public void validateClientData(CreateClientRequestDTO request) {
        if (request.getBusinessName() == null || request.getBusinessName().trim().isEmpty()) {
            throw new BusinessException("Business name is required");
        }

        if (request.getClientType() == null) {
            throw new BusinessException("Client type is required");
        }

        // Validate RNC format
        validationService.validateRNCFormat(request.getRnc());

        // Validate contract dates
        if (request.isHasContract()) {
            if (request.getContractStartDate() == null) {
                throw new BusinessException("Contract start date is required when client has contract");
            }
        }
    }

    private void setClientBusinessRules(Client client) {
        // Set business rules based on client type
        switch (client.getClientType()) {
            case SRL:
                client.setRequiresNcf(true);
                client.setRequiresRnc(true);
                client.setAppliesItbis(true);
                break;

            case PERSONA_FISICA:
                // For physical persons with RNC
                client.setRequiresNcf(client.getRnc() != null && !client.getRnc().trim().isEmpty());
                client.setRequiresRnc(client.getRnc() != null && !client.getRnc().trim().isEmpty());
                client.setAppliesItbis(true);
                break;

            case CONSUMIDOR_FINAL:
                client.setRequiresNcf(false);
                client.setRequiresRnc(false);
                client.setAppliesItbis(true); // Still applies ITBIS but no NCF
                break;
        }
    }
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\service\impl\ClientServiceImpl.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\service\impl\DashboardServiceImpl.java =====
// path: business/src/main/java/com/securitybusinesssuite/business/service/impl/DashboardServiceImpl.java
package com.securitybusinesssuite.business.service.impl;

import com.securitybusinesssuite.business.dto.dashboard.ChartDataDTO;
import com.securitybusinesssuite.business.dto.dashboard.DashboardStatsDTO;
import com.securitybusinesssuite.business.dto.dashboard.RecentActivityDTO;
import com.securitybusinesssuite.business.service.DashboardService;
import com.securitybusinesssuite.data.entity.Client;
import com.securitybusinesssuite.data.entity.Invoice;
import com.securitybusinesssuite.data.repository.ClientRepository;
import com.securitybusinesssuite.data.repository.InvoiceRepository;
import com.securitybusinesssuite.data.repository.ReceiptRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Service;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.stream.Collectors;

@Slf4j
@Service
@RequiredArgsConstructor
public class DashboardServiceImpl implements DashboardService {

    private final ClientRepository clientRepository;
    private final InvoiceRepository invoiceRepository;
    private final ReceiptRepository receiptRepository;
    private final JdbcTemplate jdbcTemplate;

    @Override
    public DashboardStatsDTO getDashboardStats() {
        // Get basic counts
        long totalClients = clientRepository.countByStatus(Client.ClientStatus.ACTIVE) +
                clientRepository.countByStatus(Client.ClientStatus.INACTIVE) +
                clientRepository.countByStatus(Client.ClientStatus.SUSPENDED);

        long activeClients = clientRepository.countByStatus(Client.ClientStatus.ACTIVE);
        long pendingInvoices = invoiceRepository.countByStatus(Invoice.InvoiceStatus.PENDING);
        long overdueInvoices = invoiceRepository.countByStatus(Invoice.InvoiceStatus.OVERDUE);

        // Get financial totals
        BigDecimal totalPendingAmount = getTotalAmountByStatus(Invoice.InvoiceStatus.PENDING);
        BigDecimal totalOverdueAmount = getTotalAmountByStatus(Invoice.InvoiceStatus.OVERDUE);
        BigDecimal monthlyRevenue = getMonthlyRevenue();
        BigDecimal yearToDateRevenue = getYearToDateRevenue();

        return DashboardStatsDTO.builder()
                .totalClients(totalClients)
                .activeClients(activeClients)
                .pendingInvoices(pendingInvoices)
                .overdueInvoices(overdueInvoices)
                .totalPendingAmount(totalPendingAmount)
                .totalOverdueAmount(totalOverdueAmount)
                .monthlyRevenue(monthlyRevenue)
                .yearToDateRevenue(yearToDateRevenue)
                .build();
    }

    @Override
    public List<RecentActivityDTO> getRecentActivity() {
        String sql = """
            (SELECT 'CLIENT_CREATED' as activity_type, c.business_name as description, 
                    c.business_name as client_name, NULL::decimal as amount, c.created_at as timestamp,
                    c.id::text as entity_id
             FROM clients c 
             WHERE c.created_at >= NOW() - INTERVAL '30 days'
             ORDER BY c.created_at DESC 
             LIMIT 5)
            UNION ALL
            (SELECT 'INVOICE_CREATED' as activity_type, 
                    'Invoice ' || i.invoice_number || ' created' as description,
                    c.business_name as client_name, i.total_amount as amount, i.created_at as timestamp,
                    i.id::text as entity_id
             FROM invoices i 
             JOIN clients c ON c.id = i.client_id
             WHERE i.created_at >= NOW() - INTERVAL '30 days'
             ORDER BY i.created_at DESC 
             LIMIT 5)
            UNION ALL
            (SELECT 'PAYMENT_RECEIVED' as activity_type,
                    'Payment ' || r.receipt_number || ' received' as description,
                    c.business_name as client_name, r.total_amount as amount, r.created_at as timestamp,
                    r.id::text as entity_id
             FROM receipts r 
             JOIN clients c ON c.id = r.client_id
             WHERE r.created_at >= NOW() - INTERVAL '30 days'
             ORDER BY r.created_at DESC 
             LIMIT 5)
            ORDER BY timestamp DESC 
            LIMIT 15
            """;

        return jdbcTemplate.query(sql, (rs, rowNum) ->
                RecentActivityDTO.builder()
                        .id(UUID.fromString(rs.getString("entity_id")))
                        .type(RecentActivityDTO.ActivityType.valueOf(rs.getString("activity_type")))
                        .description(rs.getString("description"))
                        .clientName(rs.getString("client_name"))
                        .amount(rs.getBigDecimal("amount"))
                        .timestamp(rs.getTimestamp("timestamp").toLocalDateTime())
                        .build()
        );
    }

    @Override
    public List<ChartDataDTO> getInvoicesByStatusChart() {
        String sql = """
            SELECT status, COUNT(*) as count, SUM(total_amount) as total_amount
            FROM invoices 
            WHERE created_at >= DATE_TRUNC('year', CURRENT_DATE)
            GROUP BY status
            """;

        Map<String, String> statusColors = Map.of(
                "PENDING", "#fbbf24",
                "PAID", "#10b981",
                "OVERDUE", "#ef4444",
                "CANCELLED", "#6b7280"
        );

        return jdbcTemplate.query(sql, (rs, rowNum) ->
                ChartDataDTO.builder()
                        .label(rs.getString("status"))
                        .value(rs.getBigDecimal("total_amount"))
                        .color(statusColors.getOrDefault(rs.getString("status"), "#6b7280"))
                        .build()
        );
    }

    @Override
    public List<ChartDataDTO> getRevenueByMonthChart() {
        String sql = """
            SELECT DATE_TRUNC('month', issue_date) as month,
                   SUM(total_amount) as revenue
            FROM invoices 
            WHERE issue_date >= DATE_TRUNC('year', CURRENT_DATE)
              AND status IN ('PAID', 'PENDING', 'OVERDUE')
            GROUP BY DATE_TRUNC('month', issue_date)
            ORDER BY month
            """;

        return jdbcTemplate.query(sql, (rs, rowNum) ->
                ChartDataDTO.builder()
                        .label(rs.getDate("month").toLocalDate().getMonth().toString())
                        .value(rs.getBigDecimal("revenue"))
                        .color("#3b82f6")
                        .build()
        );
    }

    @Override
    public List<ChartDataDTO> getClientsByTypeChart() {
        String sql = """
            SELECT client_type, COUNT(*) as count
            FROM clients 
            WHERE status = 'ACTIVE'
            GROUP BY client_type
            """;

        Map<String, String> typeColors = Map.of(
                "SRL", "#8b5cf6",
                "PERSONA_FISICA", "#06b6d4",
                "CONSUMIDOR_FINAL", "#84cc16"
        );

        return jdbcTemplate.query(sql, (rs, rowNum) ->
                ChartDataDTO.builder()
                        .label(rs.getString("client_type"))
                        .value(new BigDecimal(rs.getInt("count")))
                        .color(typeColors.getOrDefault(rs.getString("client_type"), "#6b7280"))
                        .build()
        );
    }

    private BigDecimal getTotalAmountByStatus(Invoice.InvoiceStatus status) {
        String sql = "SELECT COALESCE(SUM(total_amount), 0) FROM invoices WHERE status = ?::invoice_status_enum";
        return jdbcTemplate.queryForObject(sql, BigDecimal.class, status.name());
    }

    private BigDecimal getMonthlyRevenue() {
        String sql = """
            SELECT COALESCE(SUM(total_amount), 0) 
            FROM invoices 
            WHERE issue_date >= DATE_TRUNC('month', CURRENT_DATE)
              AND issue_date < DATE_TRUNC('month', CURRENT_DATE) + INTERVAL '1 month'
              AND status IN ('PAID', 'PENDING', 'OVERDUE')
            """;
        return jdbcTemplate.queryForObject(sql, BigDecimal.class);
    }

    private BigDecimal getYearToDateRevenue() {
        String sql = """
            SELECT COALESCE(SUM(total_amount), 0) 
            FROM invoices 
            WHERE issue_date >= DATE_TRUNC('year', CURRENT_DATE)
              AND status IN ('PAID', 'PENDING', 'OVERDUE')
            """;
        return jdbcTemplate.queryForObject(sql, BigDecimal.class);
    }
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\service\impl\DashboardServiceImpl.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\service\impl\EmailServiceImpl.java =====
// path: business/src/main/java/com/securitybusinesssuite/business/service/impl/EmailServiceImpl.java
package com.securitybusinesssuite.business.service.impl;

import com.securitybusinesssuite.business.service.EmailService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.mail.SimpleMailMessage;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.stereotype.Service;

@Slf4j
@Service
@RequiredArgsConstructor
public class EmailServiceImpl implements EmailService {

    private final JavaMailSender mailSender;

    @Value("${spring.mail.from}")
    private String fromEmail;

    @Value("${app.frontend.url}")
    private String frontendUrl;

    @Value("${app.backend.url}")
    private String backendUrl;

    @Value("${spring.profiles.active:dev}")
    private String activeProfile;

    @Override
    public void sendVerificationEmail(String to, String firstName, String verificationToken) {
        String verificationLink = backendUrl + "/auth/verify-email?token=" + verificationToken;

        if ("dev".equals(activeProfile)) {
            log.info("=== EMAIL VERIFICATION LINK (DEV MODE) ===");
            log.info("To: {}", to);
            log.info("Link: {}", verificationLink);
            log.info("==========================================");
            return;
        }

        SimpleMailMessage message = new SimpleMailMessage();
        message.setFrom(fromEmail);
        message.setTo(to);
        message.setSubject("Verify your email - Security Business Suite");
        message.setText(String.format("""
            Hi %s,
            
            Welcome to Security Business Suite! Please verify your email by clicking the link below:
            
            %s
            
            This link will expire in 24 hours.
            
            If you didn't create an account, please ignore this email.
            
            Best regards,
            Security Business Suite Team
            """, firstName, verificationLink));

        try {
            mailSender.send(message);
            log.info("Verification email sent to: {}", to);
        } catch (Exception e) {
            log.error("Failed to send verification email to: {}", to, e);
        }
    }

    @Override
    public void sendPasswordResetEmail(String to, String firstName, String resetToken) {
        String resetLink = frontendUrl + "/reset-password?token=" + resetToken;

        if ("dev".equals(activeProfile)) {
            log.info("=== PASSWORD RESET LINK (DEV MODE) ===");
            log.info("To: {}", to);
            log.info("Link: {}", resetLink);
            log.info("=======================================");
            return;
        }

        SimpleMailMessage message = new SimpleMailMessage();
        message.setFrom(fromEmail);
        message.setTo(to);
        message.setSubject("Password Reset - Security Business Suite");
        message.setText(String.format("""
            Hi %s,
            
            We received a request to reset your password. Click the link below to create a new password:
            
            %s
            
            This link will expire in 1 hour.
            
            If you didn't request this, please ignore this email.
            
            Best regards,
            Security Business Suite Team
            """, firstName, resetLink));

        try {
            mailSender.send(message);
            log.info("Password reset email sent to: {}", to);
        } catch (Exception e) {
            log.error("Failed to send password reset email to: {}", to, e);
        }
    }
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\service\impl\EmailServiceImpl.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\service\impl\InvoiceServiceImpl.java =====
// path: business/src/main/java/com/securitybusinesssuite/business/service/impl/InvoiceServiceImpl.java
package com.securitybusinesssuite.business.service.impl;

import com.securitybusinesssuite.business.config.DominicanTaxConfig;
import com.securitybusinesssuite.business.dto.*;
import com.securitybusinesssuite.business.dto.invoicerequest.CreateInvoiceRequestDTO;
import com.securitybusinesssuite.business.dto.invoicerequest.InvoiceItemRequestDTO;
import com.securitybusinesssuite.business.dto.invoicerequest.UpdateInvoiceRequestDTO;
import com.securitybusinesssuite.business.dto.invoiceresponse.InvoiceItemResponseDTO;
import com.securitybusinesssuite.business.dto.invoiceresponse.InvoiceResponseDTO;
import com.securitybusinesssuite.business.dto.search.InvoiceSearchCriteria;
import com.securitybusinesssuite.business.dto.search.PagedResponseDTO;
import com.securitybusinesssuite.business.exception.BusinessException;
import com.securitybusinesssuite.business.service.*;
import com.securitybusinesssuite.data.entity.*;
import com.securitybusinesssuite.data.repository.*;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

@Slf4j
@Service
@RequiredArgsConstructor
public class InvoiceServiceImpl implements InvoiceService {

    private final InvoiceRepository invoiceRepository;
    private final InvoiceItemRepository invoiceItemRepository;
    private final ClientRepository clientRepository;
    private final SequenceRepository sequenceRepository;
    private final CalculationService calculationService;
    private final NCFService ncfService;
    private final ValidationService validationService;
    private final DominicanTaxConfig taxConfig;

    @Override
    @Transactional
    public InvoiceResponseDTO createInvoice(CreateInvoiceRequestDTO request, UUID createdBy) {
        // Validate client exists
        Client client = clientRepository.findById(request.getClientId())
                .orElseThrow(() -> new BusinessException("Client not found"));

        // Generate invoice number
        String invoiceNumber = generateInvoiceNumber();

        // Generate NCF if required
        String ncf = null;
        Invoice.NCFType ncfType = null;
        if (ncfService.isNCFRequired(client)) {
            ncf = ncfService.generateNCF(client);
            ncfType = ncfService.determineNCFType(client);
        }

        // Create invoice entity
        Invoice invoice = Invoice.builder()
                .invoiceNumber(invoiceNumber)
                .ncf(ncf)
                .ncfType(ncfType)
                .clientId(request.getClientId())
                .issueDate(request.getIssueDate())
                .dueDate(request.getDueDate())
                .invoiceType(request.getInvoiceType())
                .discountAmount(request.getDiscountAmount() != null ? request.getDiscountAmount() : BigDecimal.ZERO)
                .paidAmount(BigDecimal.ZERO)
                .status(Invoice.InvoiceStatus.PENDING)
                .notes(request.getNotes())
                .createdBy(createdBy)
                .build();

        // Create invoice items
        List<InvoiceItem> items = request.getItems().stream()
                .map(itemDto -> createInvoiceItem(itemDto, createdBy))
                .collect(Collectors.toList());

        // Calculate totals
        invoice = calculationService.calculateInvoiceTotals(invoice, items);

        // Validate invoice
        validationService.validateInvoiceRequirements(invoice, client);

        // Save invoice
        Invoice savedInvoice = invoiceRepository.save(invoice);

        // Save invoice items
        for (InvoiceItem item : items) {
            item.setInvoiceId(savedInvoice.getId());
            item = calculationService.calculateLineItem(item);
            invoiceItemRepository.save(item);
        }

        // Load full invoice with items for response
        savedInvoice.setClient(client);
        savedInvoice.setItems(invoiceItemRepository.findByInvoiceId(savedInvoice.getId()));

        log.info("Invoice created: {} for client: {}", savedInvoice.getInvoiceNumber(), client.getBusinessName());
        return convertToResponseDTO(savedInvoice);
    }

    @Override
    @Transactional
    public InvoiceResponseDTO updateInvoice(UUID id, UpdateInvoiceRequestDTO request, UUID updatedBy) {
        Invoice existingInvoice = invoiceRepository.findById(id)
                .orElseThrow(() -> new BusinessException("Invoice not found"));

        if (existingInvoice.getStatus() == Invoice.InvoiceStatus.PAID) {
            throw new BusinessException("Cannot update a paid invoice");
        }

        if (existingInvoice.getStatus() == Invoice.InvoiceStatus.CANCELLED) {
            throw new BusinessException("Cannot update a cancelled invoice");
        }

        Client client = clientRepository.findById(existingInvoice.getClientId())
                .orElseThrow(() -> new BusinessException("Client not found"));

        // Update invoice fields
        existingInvoice.setDueDate(request.getDueDate());
        existingInvoice.setInvoiceType(request.getInvoiceType());
        existingInvoice.setDiscountAmount(request.getDiscountAmount() != null ? request.getDiscountAmount() : BigDecimal.ZERO);
        existingInvoice.setNotes(request.getNotes());
        existingInvoice.setUpdatedBy(updatedBy);

        // Update invoice items if provided
        if (request.getItems() != null && !request.getItems().isEmpty()) {
            // Delete existing items
            invoiceItemRepository.deleteByInvoiceId(id);

            // Create new items
            List<InvoiceItem> items = request.getItems().stream()
                    .map(itemDto -> {
                        InvoiceItem item = createInvoiceItem(itemDto, updatedBy);
                        item.setInvoiceId(id);
                        item = calculationService.calculateLineItem(item);
                        return invoiceItemRepository.save(item);
                    })
                    .collect(Collectors.toList());

            // Recalculate totals
            existingInvoice = calculationService.calculateInvoiceTotals(existingInvoice, items);
        }

        // Validate updated invoice
        validationService.validateInvoiceRequirements(existingInvoice, client);

        // Update invoice
        Invoice updatedInvoice = invoiceRepository.update(existingInvoice);
        updatedInvoice.setClient(client);
        updatedInvoice.setItems(invoiceItemRepository.findByInvoiceId(id));

        log.info("Invoice updated: {}", updatedInvoice.getInvoiceNumber());
        return convertToResponseDTO(updatedInvoice);
    }

    @Override
    public InvoiceResponseDTO getInvoice(UUID id) {
        Invoice invoice = invoiceRepository.findById(id)
                .orElseThrow(() -> new BusinessException("Invoice not found"));

        // Load related data
        Client client = clientRepository.findById(invoice.getClientId())
                .orElseThrow(() -> new BusinessException("Client not found"));
        List<InvoiceItem> items = invoiceItemRepository.findByInvoiceId(id);

        invoice.setClient(client);
        invoice.setItems(items);

        return convertToResponseDTO(invoice);
    }

    @Override
    public PagedResponseDTO<InvoiceResponseDTO> searchInvoices(InvoiceSearchCriteria criteria) {
        // Create sort
        Sort.Direction direction = "ASC".equalsIgnoreCase(criteria.getSortDirection()) ?
                Sort.Direction.ASC : Sort.Direction.DESC;
        Sort sort = Sort.by(direction, criteria.getSortBy());

        // Create pageable
        Pageable pageable = PageRequest.of(criteria.getPage(), criteria.getSize(), sort);

        // Execute search
        Page<Invoice> invoicePage = invoiceRepository.findByFilters(
                criteria.getClientId(),
                criteria.getStatus(),
                criteria.getFromDate(),
                criteria.getToDate(),
                criteria.getMinAmount(),
                criteria.getMaxAmount(),
                pageable
        );

        // Convert to DTOs with client information
        List<InvoiceResponseDTO> invoiceDTOs = invoicePage.getContent().stream()
                .map(invoice -> {
                    Client client = clientRepository.findById(invoice.getClientId()).orElse(null);
                    invoice.setClient(client);
                    return convertToResponseDTO(invoice);
                })
                .collect(Collectors.toList());

        return PagedResponseDTO.<InvoiceResponseDTO>builder()
                .content(invoiceDTOs)
                .page(invoicePage.getNumber())
                .size(invoicePage.getSize())
                .totalElements(invoicePage.getTotalElements())
                .totalPages(invoicePage.getTotalPages())
                .first(invoicePage.isFirst())
                .last(invoicePage.isLast())
                .hasNext(invoicePage.hasNext())
                .hasPrevious(invoicePage.hasPrevious())
                .build();
    }

    @Override
    @Transactional
    public void cancelInvoice(UUID id, String reason, UUID updatedBy) {
        Invoice invoice = invoiceRepository.findById(id)
                .orElseThrow(() -> new BusinessException("Invoice not found"));

        if (invoice.getStatus() == Invoice.InvoiceStatus.PAID) {
            throw new BusinessException("Cannot cancel a paid invoice");
        }

        if (invoice.getStatus() == Invoice.InvoiceStatus.CANCELLED) {
            throw new BusinessException("Invoice is already cancelled");
        }

        invoice.setStatus(Invoice.InvoiceStatus.CANCELLED);
        invoice.setNotes(invoice.getNotes() != null ?
                invoice.getNotes() + "\n\nCancelled: " + reason : "Cancelled: " + reason);
        invoice.setUpdatedBy(updatedBy);

        invoiceRepository.update(invoice);
        log.info("Invoice cancelled: {} - {}", invoice.getInvoiceNumber(), reason);
    }

    @Override
    @Transactional
    public InvoiceResponseDTO recalculateInvoice(UUID id) {
        Invoice invoice = invoiceRepository.findById(id)
                .orElseThrow(() -> new BusinessException("Invoice not found"));

        if (invoice.getStatus() == Invoice.InvoiceStatus.PAID) {
            throw new BusinessException("Cannot recalculate a paid invoice");
        }

        List<InvoiceItem> items = invoiceItemRepository.findByInvoiceId(id);

        // Recalculate line items
        items = items.stream()
                .map(calculationService::calculateLineItem)
                .map(invoiceItemRepository::update)
                .collect(Collectors.toList());

        // Recalculate invoice totals
        invoice = calculationService.calculateInvoiceTotals(invoice, items);
        invoice = invoiceRepository.update(invoice);

        // Load related data for response
        Client client = clientRepository.findById(invoice.getClientId()).orElse(null);
        invoice.setClient(client);
        invoice.setItems(items);

        log.info("Invoice recalculated: {}", invoice.getInvoiceNumber());
        return convertToResponseDTO(invoice);
    }

    @Override
    public List<InvoiceResponseDTO> getOverdueInvoices() {
        List<Invoice> overdueInvoices = invoiceRepository.findOverdueInvoices();
        return overdueInvoices.stream()
                .map(invoice -> {
                    Client client = clientRepository.findById(invoice.getClientId()).orElse(null);
                    invoice.setClient(client);
                    return convertToResponseDTO(invoice);
                })
                .collect(Collectors.toList());
    }

    @Override
    public List<InvoiceResponseDTO> getClientInvoices(UUID clientId) {
        List<Invoice> invoices = invoiceRepository.findByClientId(clientId);
        Client client = clientRepository.findById(clientId).orElse(null);

        return invoices.stream()
                .map(invoice -> {
                    invoice.setClient(client);
                    return convertToResponseDTO(invoice);
                })
                .collect(Collectors.toList());
    }

    @Override
    public List<InvoiceResponseDTO> getUnpaidInvoices(UUID clientId) {
        List<Invoice> unpaidInvoices = invoiceRepository.findByClientId(clientId).stream()
                .filter(invoice -> invoice.getStatus() == Invoice.InvoiceStatus.PENDING ||
                        invoice.getStatus() == Invoice.InvoiceStatus.OVERDUE)
                .filter(invoice -> invoice.getBalanceDue() != null &&
                        invoice.getBalanceDue().compareTo(BigDecimal.ZERO) > 0)
                .collect(Collectors.toList());

        Client client = clientRepository.findById(clientId).orElse(null);

        return unpaidInvoices.stream()
                .map(invoice -> {
                    invoice.setClient(client);
                    return convertToResponseDTO(invoice);
                })
                .collect(Collectors.toList());
    }

    @Override
    @Transactional
    public void updateInvoicePaymentStatus(UUID invoiceId) {
        Invoice invoice = invoiceRepository.findById(invoiceId)
                .orElseThrow(() -> new BusinessException("Invoice not found"));

        // Determine new status based on payment
        Invoice.InvoiceStatus newStatus;
        if (invoice.getBalanceDue() == null || invoice.getBalanceDue().compareTo(BigDecimal.ZERO) <= 0) {
            newStatus = Invoice.InvoiceStatus.PAID;
        } else if (invoice.getDueDate().isBefore(LocalDate.now())) {
            newStatus = Invoice.InvoiceStatus.OVERDUE;
        } else {
            newStatus = Invoice.InvoiceStatus.PENDING;
        }

        if (invoice.getStatus() != newStatus) {
            invoice.setStatus(newStatus);
            invoiceRepository.update(invoice);
            log.info("Invoice status updated: {} -> {}", invoice.getInvoiceNumber(), newStatus);
        }
    }

    @Transactional
    public String generateInvoiceNumber() {
        int currentYear = LocalDate.now().getYear();

        InvoiceSequence sequence = sequenceRepository.findInvoiceSequenceByYear(currentYear)
                .orElseGet(() -> {
                    InvoiceSequence newSequence = InvoiceSequence.builder()
                            .currentNumber(0)
                            .year(currentYear)
                            .build();
                    return sequenceRepository.saveInvoiceSequence(newSequence);
                });

        sequence.setCurrentNumber(sequence.getCurrentNumber() + 1);
        sequenceRepository.updateInvoiceSequence(sequence);

        // Format: INV-2024-0001
        return String.format("INV-%d-%04d", currentYear, sequence.getCurrentNumber());
    }

    private InvoiceItem createInvoiceItem(InvoiceItemRequestDTO dto, UUID createdBy) {
        return InvoiceItem.builder()
                .serviceCode(dto.getServiceCode() != null ? dto.getServiceCode() : taxConfig.getDefaultServiceCode())
                .description(dto.getDescription() != null ? dto.getDescription() : taxConfig.getDefaultServiceDescription())
                .serviceType(dto.getServiceType())
                .quantity(dto.getQuantity())
                .unitPrice(dto.getUnitPrice())
                .discountPercentage(dto.getDiscountPercentage() != null ? dto.getDiscountPercentage() : BigDecimal.ZERO)
                .itbisRate(taxConfig.getItbisRate())
                .createdBy(createdBy)
                .build();
    }

    private InvoiceResponseDTO convertToResponseDTO(Invoice invoice) {
        InvoiceResponseDTO dto = InvoiceResponseDTO.fromEntity(invoice);

        if (invoice.getItems() != null) {
            List<InvoiceItemResponseDTO> itemDTOs = invoice.getItems().stream()
                    .map(InvoiceItemResponseDTO::fromEntity)
                    .collect(Collectors.toList());
            dto.setItems(itemDTOs);
        }

        return dto;
    }
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\service\impl\InvoiceServiceImpl.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\service\impl\JwtServiceImpl.java =====
// path: business/src/main/java/com/securitybusinesssuite/business/service/impl/JwtServiceImpl.java
package com.securitybusinesssuite.business.service.impl;

import com.securitybusinesssuite.business.dto.TokenPair;
import com.securitybusinesssuite.business.service.JwtService;
import io.jsonwebtoken.*;
import io.jsonwebtoken.security.Keys;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import javax.crypto.SecretKey;
import java.nio.charset.StandardCharsets;
import java.util.Date;
import java.util.UUID;

@Slf4j
@Service
public class JwtServiceImpl implements JwtService {

    @Value("${app.jwt.secret}")
    private String jwtSecret;

    @Value("${app.jwt.access-token-expiration:900}")
    private int accessTokenExpiration; // 15 minutes

    @Value("${app.jwt.refresh-token-expiration:604800}")
    private int refreshTokenExpiration; // 7 days

    private SecretKey getSigningKey() {
        return Keys.hmacShaKeyFor(jwtSecret.getBytes(StandardCharsets.UTF_8));
    }

    @Override
    public TokenPair generateTokenPair(UUID userId, String email) {
        String accessToken = generateAccessToken(userId, email);
        String refreshToken = generateRefreshToken(userId);
        return new TokenPair(accessToken, refreshToken);
    }

    @Override
    public String generateAccessToken(UUID userId, String email) {
        Date now = new Date();
        Date expiryDate = new Date(now.getTime() + accessTokenExpiration * 1000L);

        return Jwts.builder()
                .subject(userId.toString())
                .claim("email", email)
                .claim("type", "access")
                .issuedAt(now)
                .expiration(expiryDate)
                .signWith(getSigningKey())
                .compact();
    }

    @Override
    public String generateRefreshToken(UUID userId) {
        Date now = new Date();
        Date expiryDate = new Date(now.getTime() + refreshTokenExpiration * 1000L);

        return Jwts.builder()
                .subject(userId.toString())
                .claim("type", "refresh")
                .issuedAt(now)
                .expiration(expiryDate)
                .signWith(getSigningKey())
                .compact();
    }

    @Override
    public boolean validateToken(String token) {
        try {
            Jwts.parser()
                    .verifyWith(getSigningKey())
                    .build()
                    .parseSignedClaims(token);
            return true;
        } catch (JwtException | IllegalArgumentException e) {
            log.error("Invalid JWT token: {}", e.getMessage());
            return false;
        }
    }

    @Override
    public UUID getUserIdFromToken(String token) {
        Claims claims = Jwts.parser()
                .verifyWith(getSigningKey())
                .build()
                .parseSignedClaims(token)
                .getPayload();

        return UUID.fromString(claims.getSubject());
    }

    @Override
    public String getEmailFromToken(String token) {
        Claims claims = Jwts.parser()
                .verifyWith(getSigningKey())
                .build()
                .parseSignedClaims(token)
                .getPayload();

        return claims.get("email", String.class);
    }

    @Override
    public String getTokenType(String token) {
        Claims claims = Jwts.parser()
                .verifyWith(getSigningKey())
                .build()
                .parseSignedClaims(token)
                .getPayload();

        return claims.get("type", String.class);
    }
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\service\impl\JwtServiceImpl.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\service\impl\NCFServiceImpl.java =====
// path: business/src/main/java/com/securitybusinesssuite/business/service/impl/NCFServiceImpl.java
package com.securitybusinesssuite.business.service.impl;

import com.securitybusinesssuite.business.exception.BusinessException;
import com.securitybusinesssuite.business.service.NCFService;
import com.securitybusinesssuite.data.entity.Client;
import com.securitybusinesssuite.data.entity.Invoice;
import com.securitybusinesssuite.data.entity.NCFSequence;
import com.securitybusinesssuite.data.repository.SequenceRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDate;

@Slf4j
@Service
@RequiredArgsConstructor
public class NCFServiceImpl implements NCFService {

    private final SequenceRepository sequenceRepository;

    @Override
    @Transactional
    public String generateNCF(Client client) {
        if (!isNCFRequired(client)) {
            return null;
        }

        Invoice.NCFType ncfType = determineNCFType(client);
        validateNCFAvailability(ncfType);

        int currentYear = LocalDate.now().getYear();
        NCFSequence sequence = sequenceRepository.findNCFSequenceByTypeAndYear(ncfType, currentYear)
                .orElseThrow(() -> new BusinessException("NCF sequence not found for type " + ncfType + " and year " + currentYear));

        // Increment sequence
        sequence.setCurrentNumber(sequence.getCurrentNumber() + 1);

        // Check if we've exceeded the maximum
        if (sequence.getCurrentNumber() > sequence.getMaxNumber()) {
            throw new BusinessException("NCF sequence exhausted for type " + ncfType + ". Maximum number reached: " + sequence.getMaxNumber());
        }

        // Save updated sequence
        sequenceRepository.updateNCFSequence(sequence);

        // Format NCF: B0100000001
        String ncf = String.format("%s%08d", sequence.getPrefix(), sequence.getCurrentNumber());

        log.info("Generated NCF: {} for client: {} ({})", ncf, client.getBusinessName(), client.getClientCode());
        return ncf;
    }

    @Override
    public Invoice.NCFType determineNCFType(Client client) {
        if (client.getClientType() == Client.ClientType.CONSUMIDOR_FINAL) {
            return null; // No NCF required for final consumers
        }

        // For Dominican Republic business logic:
        // B01 - Factura de Crédito Fiscal (most common for business clients)
        // B02 - Factura de Consumo (for specific scenarios)

        if (client.getClientType() == Client.ClientType.SRL ||
                client.getClientType() == Client.ClientType.PERSONA_FISICA) {
            return Invoice.NCFType.B01; // Default to B01 for business clients
        }

        return Invoice.NCFType.B01; // Default fallback
    }

    @Override
    public boolean isNCFRequired(Client client) {
        // NCF is required for all clients except CONSUMIDOR_FINAL
        return client.getClientType() != Client.ClientType.CONSUMIDOR_FINAL && client.isRequiresNcf();
    }

    @Override
    public void validateNCFAvailability(Invoice.NCFType type) {
        int currentYear = LocalDate.now().getYear();
        NCFSequence sequence = sequenceRepository.findNCFSequenceByTypeAndYear(type, currentYear)
                .orElseThrow(() -> new BusinessException("NCF sequence not initialized for type " + type + " and year " + currentYear));

        if (!sequence.isActive()) {
            throw new BusinessException("NCF sequence is not active for type " + type);
        }

        if (sequence.getCurrentNumber() >= sequence.getMaxNumber()) {
            throw new BusinessException("NCF sequence exhausted for type " + type + ". Please contact DGII for new sequence.");
        }

        // Warn when approaching limit (90% used)
        long remaining = sequence.getMaxNumber() - sequence.getCurrentNumber();
        long total = sequence.getMaxNumber();
        double percentageUsed = ((double) sequence.getCurrentNumber() / total) * 100;

        if (percentageUsed > 90) {
            log.warn("NCF sequence {} is {}% used. Only {} numbers remaining.",
                    type, String.format("%.1f", percentageUsed), remaining);
        }
    }
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\service\impl\NCFServiceImpl.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\service\impl\ReceiptServiceImpl.java =====
// path: business/src/main/java/com/securitybusinesssuite/business/service/impl/ReceiptServiceImpl.java
package com.securitybusinesssuite.business.service.impl;

import com.securitybusinesssuite.business.dto.*;
import com.securitybusinesssuite.business.dto.receiptrequest.CreateReceiptRequestDTO;
import com.securitybusinesssuite.business.dto.receiptrequest.PaymentAllocationDTO;
import com.securitybusinesssuite.business.dto.receiptrequest.UpdateReceiptRequestDTO;
import com.securitybusinesssuite.business.dto.receiptresponse.ReceiptAllocationResponseDTO;
import com.securitybusinesssuite.business.dto.receiptresponse.ReceiptResponseDTO;
import com.securitybusinesssuite.business.dto.search.PagedResponseDTO;
import com.securitybusinesssuite.business.dto.search.ReceiptSearchCriteria;
import com.securitybusinesssuite.business.exception.BusinessException;
import com.securitybusinesssuite.business.service.InvoiceService;
import com.securitybusinesssuite.business.service.ReceiptService;
import com.securitybusinesssuite.business.service.ValidationService;
import com.securitybusinesssuite.data.entity.*;
import com.securitybusinesssuite.data.repository.*;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

@Slf4j
@Service
@RequiredArgsConstructor
public class ReceiptServiceImpl implements ReceiptService {

    private final ReceiptRepository receiptRepository;
    private final ReceiptAllocationRepository receiptAllocationRepository;
    private final ClientRepository clientRepository;
    private final InvoiceRepository invoiceRepository;
    private final SequenceRepository sequenceRepository;
    private final ValidationService validationService;
    private final InvoiceService invoiceService;

    @Override
    @Transactional
    public ReceiptResponseDTO createReceipt(CreateReceiptRequestDTO request, UUID createdBy) {
        // Validate client exists
        Client client = clientRepository.findById(request.getClientId())
                .orElseThrow(() -> new BusinessException("Client not found"));

        // Validate payment method details
        validationService.validatePaymentMethodDetails(
                request.getPaymentMethod(),
                request.getCheckNumber(),
                request.getBankName(),
                request.getReferenceNumber()
        );

        // Generate receipt number
        String receiptNumber = generateReceiptNumber();

        // Create receipt entity
        Receipt receipt = Receipt.builder()
                .receiptNumber(receiptNumber)
                .clientId(request.getClientId())
                .issueDate(request.getIssueDate())
                .totalAmount(request.getTotalAmount())
                .paymentMethod(request.getPaymentMethod())
                .currency(request.getCurrency() != null ? request.getCurrency() : "DOP")
                .checkNumber(request.getCheckNumber())
                .bankName(request.getBankName())
                .referenceNumber(request.getReferenceNumber())
                .status(Receipt.ReceiptStatus.ACTIVE)
                .notes(request.getNotes())
                .createdBy(createdBy)
                .build();

        // Save receipt
        Receipt savedReceipt = receiptRepository.save(receipt);

        // Process allocations if provided
        if (request.getAllocations() != null && !request.getAllocations().isEmpty()) {
            allocatePayment(savedReceipt.getId(), request.getAllocations(), createdBy);
        }

        // Load full receipt for response
        return getReceipt(savedReceipt.getId());
    }

    @Override
    @Transactional
    public ReceiptResponseDTO updateReceipt(UUID id, UpdateReceiptRequestDTO request, UUID updatedBy) {
        Receipt existingReceipt = receiptRepository.findById(id)
                .orElseThrow(() -> new BusinessException("Receipt not found"));

        if (existingReceipt.getStatus() == Receipt.ReceiptStatus.VOIDED) {
            throw new BusinessException("Cannot update a voided receipt");
        }

        // Validate payment method details
        validationService.validatePaymentMethodDetails(
                request.getPaymentMethod(),
                request.getCheckNumber(),
                request.getBankName(),
                request.getReferenceNumber()
        );

        // Update receipt fields
        existingReceipt.setIssueDate(request.getIssueDate());
        existingReceipt.setTotalAmount(request.getTotalAmount());
        existingReceipt.setPaymentMethod(request.getPaymentMethod());
        existingReceipt.setCurrency(request.getCurrency());
        existingReceipt.setCheckNumber(request.getCheckNumber());
        existingReceipt.setBankName(request.getBankName());
        existingReceipt.setReferenceNumber(request.getReferenceNumber());
        existingReceipt.setStatus(request.getStatus());
        existingReceipt.setNotes(request.getNotes());
        existingReceipt.setUpdatedBy(updatedBy);

        // Update receipt
        Receipt updatedReceipt = receiptRepository.update(existingReceipt);

        log.info("Receipt updated: {}", updatedReceipt.getReceiptNumber());
        return getReceipt(updatedReceipt.getId());
    }

    @Override
    public ReceiptResponseDTO getReceipt(UUID id) {
        Receipt receipt = receiptRepository.findById(id)
                .orElseThrow(() -> new BusinessException("Receipt not found"));

        // Load related data
        Client client = clientRepository.findById(receipt.getClientId()).orElse(null);
        List<ReceiptAllocation> allocations = receiptAllocationRepository.findByReceiptId(id);

        // Load invoices for allocations
        for (ReceiptAllocation allocation : allocations) {
            Invoice invoice = invoiceRepository.findById(allocation.getInvoiceId()).orElse(null);
            if (invoice != null && client != null) {
                invoice.setClient(client);
            }
            allocation.setInvoice(invoice);
        }

        receipt.setClient(client);
        receipt.setAllocations(allocations);

        return convertToResponseDTO(receipt);
    }

    @Override
    public PagedResponseDTO<ReceiptResponseDTO> searchReceipts(ReceiptSearchCriteria criteria) {
        // Create sort
        Sort.Direction direction = "ASC".equalsIgnoreCase(criteria.getSortDirection()) ?
                Sort.Direction.ASC : Sort.Direction.DESC;
        Sort sort = Sort.by(direction, criteria.getSortBy());

        // Create pageable
        Pageable pageable = PageRequest.of(criteria.getPage(), criteria.getSize(), sort);

        // Execute search
        Page<Receipt> receiptPage = receiptRepository.findByFilters(
                criteria.getClientId(),
                criteria.getStatus(),
                criteria.getFromDate(),
                criteria.getToDate(),
                pageable
        );

        // Convert to DTOs with client information
        List<ReceiptResponseDTO> receiptDTOs = receiptPage.getContent().stream()
                .map(receipt -> {
                    Client client = clientRepository.findById(receipt.getClientId()).orElse(null);
                    receipt.setClient(client);

                    List<ReceiptAllocation> allocations = receiptAllocationRepository.findByReceiptId(receipt.getId());
                    receipt.setAllocations(allocations);

                    return convertToResponseDTO(receipt);
                })
                .collect(Collectors.toList());

        return PagedResponseDTO.<ReceiptResponseDTO>builder()
                .content(receiptDTOs)
                .page(receiptPage.getNumber())
                .size(receiptPage.getSize())
                .totalElements(receiptPage.getTotalElements())
                .totalPages(receiptPage.getTotalPages())
                .first(receiptPage.isFirst())
                .last(receiptPage.isLast())
                .hasNext(receiptPage.hasNext())
                .hasPrevious(receiptPage.hasPrevious())
                .build();
    }

    @Override
    @Transactional
    public void voidReceipt(UUID id, String reason, UUID updatedBy) {
        Receipt receipt = receiptRepository.findById(id)
                .orElseThrow(() -> new BusinessException("Receipt not found"));

        if (receipt.getStatus() == Receipt.ReceiptStatus.VOIDED) {
            throw new BusinessException("Receipt is already voided");
        }

        // Remove all allocations and update invoice payment status
        List<ReceiptAllocation> allocations = receiptAllocationRepository.findByReceiptId(id);
        for (ReceiptAllocation allocation : allocations) {
            // Update invoice paid amount
            Invoice invoice = invoiceRepository.findById(allocation.getInvoiceId())
                    .orElseThrow(() -> new BusinessException("Invoice not found"));

            BigDecimal newPaidAmount = invoice.getPaidAmount().subtract(allocation.getAllocatedAmount());
            BigDecimal newBalance = invoice.getTotalAmount().subtract(newPaidAmount);

            invoice.setPaidAmount(newPaidAmount);
            invoice.setBalanceDue(newBalance);

            invoiceRepository.update(invoice);
            invoiceService.updateInvoicePaymentStatus(invoice.getId());

            // Delete allocation
            receiptAllocationRepository.deleteById(allocation.getId());
        }

        // Update receipt status
        receipt.setStatus(Receipt.ReceiptStatus.VOIDED);
        receipt.setNotes(receipt.getNotes() != null ?
                receipt.getNotes() + "\n\nVoided: " + reason : "Voided: " + reason);
        receipt.setUpdatedBy(updatedBy);

        receiptRepository.update(receipt);
        log.info("Receipt voided: {} - {}", receipt.getReceiptNumber(), reason);
    }

    @Override
    @Transactional
    public void allocatePayment(UUID receiptId, List<PaymentAllocationDTO> allocations, UUID createdBy) {
        Receipt receipt = receiptRepository.findById(receiptId)
                .orElseThrow(() -> new BusinessException("Receipt not found"));

        if (receipt.getStatus() != Receipt.ReceiptStatus.ACTIVE) {
            throw new BusinessException("Can only allocate payments for active receipts");
        }

        // Validate total allocation doesn't exceed receipt amount
        BigDecimal totalRequested = allocations.stream()
                .map(PaymentAllocationDTO::getAllocatedAmount)
                .reduce(BigDecimal.ZERO, BigDecimal::add);

        BigDecimal currentlyAllocated = receiptAllocationRepository.getTotalAllocatedByReceiptId(receiptId);
        BigDecimal available = receipt.getTotalAmount().subtract(currentlyAllocated);

        if (totalRequested.compareTo(available) > 0) {
            throw new BusinessException(String.format(
                    "Cannot allocate %.2f. Only %.2f available for allocation.",
                    totalRequested, available
            ));
        }

        // Process each allocation
        for (PaymentAllocationDTO allocationDto : allocations) {
            Invoice invoice = invoiceRepository.findById(allocationDto.getInvoiceId())
                    .orElseThrow(() -> new BusinessException("Invoice not found"));

            // Validate invoice belongs to same client
            if (!invoice.getClientId().equals(receipt.getClientId())) {
                throw new BusinessException("Invoice must belong to the same client as the receipt");
            }

            // Check if invoice needs payment
            if (invoice.getBalanceDue().compareTo(BigDecimal.ZERO) <= 0) {
                throw new BusinessException("Invoice " + invoice.getInvoiceNumber() + " is already fully paid");
            }

            // Don't allow overpayment of invoice
            if (allocationDto.getAllocatedAmount().compareTo(invoice.getBalanceDue()) > 0) {
                throw new BusinessException(String.format(
                        "Cannot allocate %.2f to invoice %s. Maximum allocation is %.2f",
                        allocationDto.getAllocatedAmount(), invoice.getInvoiceNumber(), invoice.getBalanceDue()
                ));
            }

            // Create allocation record
            ReceiptAllocation allocation = ReceiptAllocation.builder()
                    .receiptId(receiptId)
                    .invoiceId(allocationDto.getInvoiceId())
                    .allocatedAmount(allocationDto.getAllocatedAmount())
                    .createdBy(createdBy)
                    .build();

            receiptAllocationRepository.save(allocation);

            // Update invoice payment status
            BigDecimal newPaidAmount = invoice.getPaidAmount().add(allocationDto.getAllocatedAmount());
            BigDecimal newBalance = invoice.getTotalAmount().subtract(newPaidAmount);

            invoice.setPaidAmount(newPaidAmount);
            invoice.setBalanceDue(newBalance);

            invoiceRepository.update(invoice);
            invoiceService.updateInvoicePaymentStatus(invoice.getId());
        }

        log.info("Payment allocated for receipt: {} to {} invoices", receipt.getReceiptNumber(), allocations.size());
    }

    @Override
    public BigDecimal getAvailableAmount(UUID receiptId) {
        Receipt receipt = receiptRepository.findById(receiptId)
                .orElseThrow(() -> new BusinessException("Receipt not found"));

        BigDecimal allocated = receiptAllocationRepository.getTotalAllocatedByReceiptId(receiptId);
        return receipt.getTotalAmount().subtract(allocated != null ? allocated : BigDecimal.ZERO);
    }

    @Override
    public List<ReceiptResponseDTO> getClientReceipts(UUID clientId) {
        List<Receipt> receipts = receiptRepository.findByClientId(clientId);
        Client client = clientRepository.findById(clientId).orElse(null);

        return receipts.stream()
                .map(receipt -> {
                    receipt.setClient(client);
                    List<ReceiptAllocation> allocations = receiptAllocationRepository.findByReceiptId(receipt.getId());
                    receipt.setAllocations(allocations);
                    return convertToResponseDTO(receipt);
                })
                .collect(Collectors.toList());
    }

    @Transactional
    public String generateReceiptNumber() {
        int currentYear = LocalDate.now().getYear();

        ReceiptSequence sequence = sequenceRepository.findReceiptSequenceByYear(currentYear)
                .orElseGet(() -> {
                    ReceiptSequence newSequence = ReceiptSequence.builder()
                            .currentNumber(0)
                            .prefix("REC")
                            .year(currentYear)
                            .build();
                    return sequenceRepository.saveReceiptSequence(newSequence);
                });

        sequence.setCurrentNumber(sequence.getCurrentNumber() + 1);
        sequenceRepository.updateReceiptSequence(sequence);

        // Format: REC-2024-0001
        return String.format("%s-%d-%04d", sequence.getPrefix(), currentYear, sequence.getCurrentNumber());
    }

    private ReceiptResponseDTO convertToResponseDTO(Receipt receipt) {
        ReceiptResponseDTO dto = ReceiptResponseDTO.fromEntity(receipt);

        if (receipt.getAllocations() != null) {
            List<ReceiptAllocationResponseDTO> allocationDTOs = receipt.getAllocations().stream()
                    .map(ReceiptAllocationResponseDTO::fromEntity)
                    .collect(Collectors.toList());
            dto.setAllocations(allocationDTOs);

            BigDecimal totalAllocated = receipt.getAllocations().stream()
                    .map(ReceiptAllocation::getAllocatedAmount)
                    .reduce(BigDecimal.ZERO, BigDecimal::add);

            dto.setAllocatedAmount(totalAllocated);
            dto.setAvailableAmount(receipt.getTotalAmount().subtract(totalAllocated));
        } else {
            dto.setAllocatedAmount(BigDecimal.ZERO);
            dto.setAvailableAmount(receipt.getTotalAmount());
        }

        return dto;
    }
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\service\impl\ReceiptServiceImpl.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\service\impl\UserServiceImpl.java =====
// path: business/src/main/java/com/securitybusinesssuite/business/service/impl/UserServiceImpl.java
package com.securitybusinesssuite.business.service.impl;

import com.securitybusinesssuite.business.dto.UserDto;
import com.securitybusinesssuite.business.exception.BusinessException;
import com.securitybusinesssuite.business.service.UserService;
import com.securitybusinesssuite.data.entity.User;
import com.securitybusinesssuite.data.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.util.UUID;

@Service
@RequiredArgsConstructor
public class UserServiceImpl implements UserService {

    private final UserRepository userRepository;

    @Override
    public UserDto getUserById(UUID id) {
        User user = userRepository.findById(id)
                .orElseThrow(() -> new BusinessException("User not found"));
        return UserDto.fromEntity(user);
    }

    @Override
    public User findByEmail(String email) {
        return userRepository.findByEmail(email)
                .orElseThrow(() -> new BusinessException("User not found"));
    }

    @Override
    public User findById(UUID id) {
        return userRepository.findById(id)
                .orElseThrow(() -> new BusinessException("User not found"));
    }
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\service\impl\UserServiceImpl.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\service\impl\ValidationServiceImpl.java =====
// path: business/src/main/java/com/securitybusinesssuite/business/service/impl/ValidationServiceImpl.java
package com.securitybusinesssuite.business.service.impl;

import com.securitybusinesssuite.business.config.DominicanTaxConfig;
import com.securitybusinesssuite.business.exception.BusinessException;
import com.securitybusinesssuite.business.service.ValidationService;
import com.securitybusinesssuite.data.entity.Client;
import com.securitybusinesssuite.data.entity.Invoice;
import com.securitybusinesssuite.data.entity.Receipt;
import com.securitybusinesssuite.data.entity.ReceiptAllocation;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.math.BigDecimal;
import java.util.List;
import java.util.regex.Pattern;

@Service
@RequiredArgsConstructor
public class ValidationServiceImpl implements ValidationService {

    private final DominicanTaxConfig taxConfig;

    @Override
    public void validateRNCFormat(String rnc) {
        if (rnc == null || rnc.trim().isEmpty()) {
            return; // RNC is optional for some client types
        }

        Pattern rncPattern = Pattern.compile(DominicanTaxConfig.RNC_PATTERN);
        if (!rncPattern.matcher(rnc.trim()).matches()) {
            throw new BusinessException("RNC must be in format XXX-XXXXXXX-X (e.g., 123-1234567-8)");
        }
    }

    @Override
    public void validateClientRequirements(Client client) {
        // Validate RNC format
        validateRNCFormat(client.getRnc());

        // Business rules for different client types
        switch (client.getClientType()) {
            case SRL:
                if (client.getRnc() == null || client.getRnc().trim().isEmpty()) {
                    throw new BusinessException("SRL clients must have a valid RNC");
                }
                if (!client.isRequiresNcf()) {
                    throw new BusinessException("SRL clients must require NCF");
                }
                if (!client.isRequiresRnc()) {
                    throw new BusinessException("SRL clients must require RNC validation");
                }
                break;

            case PERSONA_FISICA:
                // Physical persons may or may not have RNC depending on their business activities
                if (client.getRnc() != null && !client.getRnc().trim().isEmpty()) {
                    if (!client.isRequiresRnc()) {
                        throw new BusinessException("If RNC is provided, client must require RNC validation");
                    }
                }
                break;

            case CONSUMIDOR_FINAL:
                if (client.getRnc() != null && !client.getRnc().trim().isEmpty()) {
                    throw new BusinessException("Final consumers should not have RNC");
                }
                if (client.isRequiresNcf()) {
                    throw new BusinessException("Final consumers do not require NCF");
                }
                break;
        }

        // Validate contract dates
        if (client.isHasContract()) {
            if (client.getContractStartDate() == null) {
                throw new BusinessException("Contract start date is required when client has contract");
            }
            if (client.getContractEndDate() == null && !client.isAutoRenewal()) {
                throw new BusinessException("Contract end date is required when auto-renewal is disabled");
            }
            if (client.getContractStartDate() != null && client.getContractEndDate() != null) {
                if (client.getContractStartDate().isAfter(client.getContractEndDate())) {
                    throw new BusinessException("Contract start date cannot be after end date");
                }
            }
        }

        // Validate hourly rate
        if (client.getHourlyRate() != null && client.getHourlyRate().compareTo(BigDecimal.ZERO) <= 0) {
            throw new BusinessException("Hourly rate must be positive");
        }

        // Validate business name
        if (client.getBusinessName() == null || client.getBusinessName().trim().isEmpty()) {
            throw new BusinessException("Business name is required");
        }
    }

    @Override
    public void validateInvoiceRequirements(Invoice invoice, Client client) {
        // Validate due date
        if (invoice.getDueDate() != null && invoice.getIssueDate() != null) {
            if (invoice.getDueDate().isBefore(invoice.getIssueDate())) {
                throw new BusinessException("Due date cannot be before issue date");
            }
        }

        // Validate NCF requirements
        if (client.isRequiresNcf() && (invoice.getNcf() == null || invoice.getNcf().trim().isEmpty())) {
            throw new BusinessException("NCF is required for this client type");
        }

        if (!client.isRequiresNcf() && invoice.getNcf() != null && !invoice.getNcf().trim().isEmpty()) {
            throw new BusinessException("NCF should not be provided for this client type");
        }

        // Validate amounts
        validateInvoiceAmounts(invoice);
    }

    @Override
    public void validateReceiptAllocation(Receipt receipt, List<ReceiptAllocation> allocations) {
        if (allocations == null || allocations.isEmpty()) {
            return; // No allocations to validate
        }

        BigDecimal totalAllocated = allocations.stream()
                .map(ReceiptAllocation::getAllocatedAmount)
                .reduce(BigDecimal.ZERO, BigDecimal::add);

        if (totalAllocated.compareTo(receipt.getTotalAmount()) > 0) {
            throw new BusinessException(
                    String.format("Total allocated amount (%.2f) cannot exceed receipt amount (%.2f)",
                            totalAllocated, receipt.getTotalAmount())
            );
        }

        // Validate individual allocations
        for (ReceiptAllocation allocation : allocations) {
            if (allocation.getAllocatedAmount() == null || allocation.getAllocatedAmount().compareTo(BigDecimal.ZERO) <= 0) {
                throw new BusinessException("Allocation amount must be positive");
            }
        }
    }

    @Override
    public void validateInvoiceAmounts(Invoice invoice) {
        // Validate that all amounts are non-negative
        if (invoice.getSubtotal() != null && invoice.getSubtotal().compareTo(BigDecimal.ZERO) < 0) {
            throw new BusinessException("Subtotal cannot be negative");
        }

        if (invoice.getItbisAmount() != null && invoice.getItbisAmount().compareTo(BigDecimal.ZERO) < 0) {
            throw new BusinessException("ITBIS amount cannot be negative");
        }

        if (invoice.getDiscountAmount() != null && invoice.getDiscountAmount().compareTo(BigDecimal.ZERO) < 0) {
            throw new BusinessException("Discount amount cannot be negative");
        }

        if (invoice.getTotalAmount() != null && invoice.getTotalAmount().compareTo(BigDecimal.ZERO) <= 0) {
            throw new BusinessException("Total amount must be positive");
        }

        if (invoice.getPaidAmount() != null && invoice.getPaidAmount().compareTo(BigDecimal.ZERO) < 0) {
            throw new BusinessException("Paid amount cannot be negative");
        }

        // Validate that paid amount doesn't exceed total amount
        if (invoice.getPaidAmount() != null && invoice.getTotalAmount() != null) {
            if (invoice.getPaidAmount().compareTo(invoice.getTotalAmount()) > 0) {
                throw new BusinessException("Paid amount cannot exceed total amount");
            }
        }
    }

    @Override
    public void validatePaymentMethodDetails(Client.PaymentMethod method, String checkNumber, String bankName, String referenceNumber) {
        switch (method) {
            case CHEQUE:
                if (checkNumber == null || checkNumber.trim().isEmpty()) {
                    throw new BusinessException("Check number is required for check payments");
                }
                if (bankName == null || bankName.trim().isEmpty()) {
                    throw new BusinessException("Bank name is required for check payments");
                }
                break;

            case TRANSFERENCIA_BANCARIA:
                if (referenceNumber == null || referenceNumber.trim().isEmpty()) {
                    throw new BusinessException("Reference number is required for bank transfer payments");
                }
                if (bankName == null || bankName.trim().isEmpty()) {
                    throw new BusinessException("Bank name is required for bank transfer payments");
                }
                break;

            case EFECTIVO:
                // No additional validation required for cash payments
                break;
        }
    }
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\service\impl\ValidationServiceImpl.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\service\InvoiceService.java =====
// path: business/src/main/java/com/securitybusinesssuite/business/service/InvoiceService.java
package com.securitybusinesssuite.business.service;

import com.securitybusinesssuite.business.dto.invoicerequest.CreateInvoiceRequestDTO;
import com.securitybusinesssuite.business.dto.invoicerequest.UpdateInvoiceRequestDTO;
import com.securitybusinesssuite.business.dto.invoiceresponse.InvoiceResponseDTO;
import com.securitybusinesssuite.business.dto.search.InvoiceSearchCriteria;
import com.securitybusinesssuite.business.dto.search.PagedResponseDTO;

import java.util.List;
import java.util.UUID;

public interface InvoiceService {
    InvoiceResponseDTO createInvoice(CreateInvoiceRequestDTO request, UUID createdBy);
    InvoiceResponseDTO updateInvoice(UUID id, UpdateInvoiceRequestDTO request, UUID updatedBy);
    InvoiceResponseDTO getInvoice(UUID id);
    PagedResponseDTO<InvoiceResponseDTO> searchInvoices(InvoiceSearchCriteria criteria);
    void cancelInvoice(UUID id, String reason, UUID updatedBy);
    InvoiceResponseDTO recalculateInvoice(UUID id);
    List<InvoiceResponseDTO> getOverdueInvoices();
    List<InvoiceResponseDTO> getClientInvoices(UUID clientId);
    List<InvoiceResponseDTO> getUnpaidInvoices(UUID clientId);
    void updateInvoicePaymentStatus(UUID invoiceId);
}

===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\service\InvoiceService.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\service\JwtService.java =====
// path: business/src/main/java/com/securitybusinesssuite/business/service/JwtService.java
package com.securitybusinesssuite.business.service;

import com.securitybusinesssuite.business.dto.TokenPair;

import java.util.UUID;

public interface JwtService {
    TokenPair generateTokenPair(UUID userId, String email);
    String generateAccessToken(UUID userId, String email);
    String generateRefreshToken(UUID userId);
    boolean validateToken(String token);
    UUID getUserIdFromToken(String token);
    String getEmailFromToken(String token);
    String getTokenType(String token);
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\service\JwtService.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\service\NCFService.java =====
// path: business/src/main/java/com/securitybusinesssuite/business/service/NCFService.java
package com.securitybusinesssuite.business.service;

import com.securitybusinesssuite.data.entity.Client;
import com.securitybusinesssuite.data.entity.Invoice;

public interface NCFService {
    String generateNCF(Client client);
    Invoice.NCFType determineNCFType(Client client);
    boolean isNCFRequired(Client client);
    void validateNCFAvailability(Invoice.NCFType type);
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\service\NCFService.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\service\ReceiptService.java =====
// path: business/src/main/java/com/securitybusinesssuite/business/service/ReceiptService.java
package com.securitybusinesssuite.business.service;

import com.securitybusinesssuite.business.dto.*;
import com.securitybusinesssuite.business.dto.receiptrequest.CreateReceiptRequestDTO;
import com.securitybusinesssuite.business.dto.receiptrequest.PaymentAllocationDTO;
import com.securitybusinesssuite.business.dto.receiptrequest.UpdateReceiptRequestDTO;
import com.securitybusinesssuite.business.dto.receiptresponse.ReceiptResponseDTO;
import com.securitybusinesssuite.business.dto.search.PagedResponseDTO;
import com.securitybusinesssuite.business.dto.search.ReceiptSearchCriteria;

import java.math.BigDecimal;
import java.util.List;
import java.util.UUID;

public interface ReceiptService {
    ReceiptResponseDTO createReceipt(CreateReceiptRequestDTO request, UUID createdBy);
    ReceiptResponseDTO updateReceipt(UUID id, UpdateReceiptRequestDTO request, UUID updatedBy);
    ReceiptResponseDTO getReceipt(UUID id);
    PagedResponseDTO<ReceiptResponseDTO> searchReceipts(ReceiptSearchCriteria criteria);
    void voidReceipt(UUID id, String reason, UUID updatedBy);
    void allocatePayment(UUID receiptId, List<PaymentAllocationDTO> allocations, UUID createdBy);
    BigDecimal getAvailableAmount(UUID receiptId);
    List<ReceiptResponseDTO> getClientReceipts(UUID clientId);
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\service\ReceiptService.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\service\UserService.java =====
// path: business/src/main/java/com/securitybusinesssuite/business/service/UserService.java
package com.securitybusinesssuite.business.service;

import com.securitybusinesssuite.business.dto.UserDto;
import com.securitybusinesssuite.data.entity.User;

import java.util.UUID;

public interface UserService {
    UserDto getUserById(UUID id);
    User findByEmail(String email);
    User findById(UUID id);
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\service\UserService.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\service\ValidationService.java =====
// path: business/src/main/java/com/securitybusinesssuite/business/service/ValidationService.java
package com.securitybusinesssuite.business.service;

import com.securitybusinesssuite.data.entity.Client;
import com.securitybusinesssuite.data.entity.Invoice;
import com.securitybusinesssuite.data.entity.Receipt;
import com.securitybusinesssuite.data.entity.ReceiptAllocation;
import java.util.List;

public interface ValidationService {
    void validateRNCFormat(String rnc);
    void validateClientRequirements(Client client);
    void validateInvoiceRequirements(Invoice invoice, Client client);
    void validateReceiptAllocation(Receipt receipt, List<ReceiptAllocation> allocations);
    void validateInvoiceAmounts(Invoice invoice);
    void validatePaymentMethodDetails(Client.PaymentMethod method, String checkNumber, String bankName, String referenceNumber);
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\service\ValidationService.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\util\CookieUtil.java =====
// path: business/src/main/java/com/securitybusinesssuite/business/util/CookieUtil.java
package com.securitybusinesssuite.business.util;

import jakarta.servlet.http.Cookie;
import jakarta.servlet.http.HttpServletRequest;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import java.util.Arrays;

@Component
public class CookieUtil {

    @Value("${app.jwt.access-token-expiration:900}")
    private int accessTokenExpiration;

    @Value("${app.jwt.refresh-token-expiration:604800}")
    private int refreshTokenExpiration;

    @Value("${app.cookie.secure:false}")
    private boolean secureCookie;

    @Value("${app.cookie.domain:localhost}")
    private String cookieDomain;

    public Cookie createAccessTokenCookie(String token) {
        return createCookie("access_token", token, accessTokenExpiration);
    }

    public Cookie createRefreshTokenCookie(String token) {
        return createCookie("refresh_token", token, refreshTokenExpiration);
    }

    public Cookie createLogoutCookie(String name) {
        Cookie cookie = new Cookie(name, "");
        cookie.setMaxAge(0);
        cookie.setHttpOnly(true);
        cookie.setSecure(secureCookie);
        cookie.setPath("/");
        return cookie;
    }

    private Cookie createCookie(String name, String value, int maxAge) {
        Cookie cookie = new Cookie(name, value);
        cookie.setMaxAge(maxAge);
        cookie.setHttpOnly(true);
        cookie.setSecure(secureCookie);
        cookie.setPath("/");
        cookie.setAttribute("SameSite", "Lax");
        return cookie;
    }

    public String extractTokenFromCookies(HttpServletRequest request, String cookieName) {
        if (request.getCookies() != null) {
            return Arrays.stream(request.getCookies())
                    .filter(cookie -> cookieName.equals(cookie.getName()))
                    .map(Cookie::getValue)
                    .findFirst()
                    .orElse(null);
        }
        return null;
    }

    public String getAccessToken(HttpServletRequest request) {
        return extractTokenFromCookies(request, "access_token");
    }

    public String getRefreshToken(HttpServletRequest request) {
        return extractTokenFromCookies(request, "refresh_token");
    }
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\business\src\main\java\com\securitybusinesssuite\business\util\CookieUtil.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\data\build.gradle.kts =====
// path: data/build.gradle.kts
plugins {
    id("org.springframework.boot") apply false
    id("io.spring.dependency-management")
}

dependencies {
    implementation("org.springframework.boot:spring-boot-starter-jdbc")
    implementation("org.postgresql:postgresql")
    implementation("org.flywaydb:flyway-core")
    implementation("org.flywaydb:flyway-database-postgresql")
    implementation("com.zaxxer:HikariCP")
    implementation("org.springframework.data:spring-data-commons")
    compileOnly("org.projectlombok:lombok:1.18.34")
    annotationProcessor("org.projectlombok:lombok:1.18.34")

    testImplementation("org.springframework.boot:spring-boot-starter-test")
}

dependencyManagement {
    imports {
        mavenBom("org.springframework.boot:spring-boot-dependencies:3.3.5")
    }
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\data\build.gradle.kts =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\data\src\main\java\com\securitybusinesssuite\data\config\DataSourceConfig.java =====
// path: data/src/main/java/com/securitybusinesssuite/data/config/DataSourceConfig.java
package com.securitybusinesssuite.data.config;

import com.zaxxer.hikari.HikariConfig;
import com.zaxxer.hikari.HikariDataSource;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.jdbc.core.JdbcTemplate;

import javax.sql.DataSource;

@Configuration
public class DataSourceConfig {

    @Value("${spring.datasource.url}")
    private String jdbcUrl;

    @Value("${spring.datasource.username}")
    private String username;

    @Value("${spring.datasource.password}")
    private String password;

    @Value("${spring.datasource.hikari.maximum-pool-size:10}")
    private int maxPoolSize;

    @Bean
    public DataSource dataSource() {
        HikariConfig config = new HikariConfig();
        config.setJdbcUrl(jdbcUrl);
        config.setUsername(username);
        config.setPassword(password);
        config.setMaximumPoolSize(maxPoolSize);
        config.setMinimumIdle(2);
        config.setConnectionTimeout(30000);
        config.setIdleTimeout(600000);
        config.setMaxLifetime(1800000);

        return new HikariDataSource(config);
    }

    @Bean
    public JdbcTemplate jdbcTemplate(DataSource dataSource) {
        return new JdbcTemplate(dataSource);
    }
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\data\src\main\java\com\securitybusinesssuite\data\config\DataSourceConfig.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\data\src\main\java\com\securitybusinesssuite\data\entity\Client.java =====
// path: data/src/main/java/com/securitybusinesssuite/data/entity/Client.java
package com.securitybusinesssuite.data.entity;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.math.BigDecimal;
import java.util.List;
import java.util.UUID;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class Client {
    private UUID id;
    private String clientCode;
    private String rnc;
    private ClientType clientType;
    private String businessName;
    private String contactPerson;
    private BusinessSector businessSector;
    private String phone;
    private String email;
    private String streetName;
    private String streetNumber;
    private String sector;
    private String provincia;
    private List<SecurityService> services;
    private boolean hasContract;
    private LocalDate contractStartDate;
    private LocalDate contractEndDate;
    private boolean autoRenewal;
    private PaymentMethod paymentMethod;
    private BigDecimal hourlyRate;
    private boolean requiresNcf;
    private boolean requiresRnc;
    private boolean appliesItbis;
    private ClientStatus status;
    private String notes;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
    private UUID createdBy;
    private UUID updatedBy;

    public enum ClientType {
        PERSONA_FISICA, SRL, CONSUMIDOR_FINAL
    }

    public enum BusinessSector {
        DEALER_AUTOS, RESIDENCIAL, COOPERATIVA, GOBIERNO, INDIVIDUAL
    }

    public enum SecurityService {
        PUESTO_FIJO, PATRULLAJE, ESCOLTA
    }

    public enum PaymentMethod {
        EFECTIVO, CHEQUE, TRANSFERENCIA_BANCARIA
    }

    public enum ClientStatus {
        ACTIVE, INACTIVE, SUSPENDED
    }
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\data\src\main\java\com\securitybusinesssuite\data\entity\Client.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\data\src\main\java\com\securitybusinesssuite\data\entity\ClientSequence.java =====
// path: data/src/main/java/com/securitybusinesssuite/data/entity/ClientSequence.java
package com.securitybusinesssuite.data.entity;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.UUID;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ClientSequence {
    private UUID id;
    private Integer currentNumber;
    private String prefix;
    private Integer year;
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\data\src\main\java\com\securitybusinesssuite\data\entity\ClientSequence.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\data\src\main\java\com\securitybusinesssuite\data\entity\Invoice.java =====
// path: data/src/main/java/com/securitybusinesssuite/data/entity/Invoice.java
package com.securitybusinesssuite.data.entity;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.List;
import java.util.UUID;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class Invoice {
    private UUID id;
    private String invoiceNumber;
    private String ncf;
    private NCFType ncfType;
    private UUID clientId;
    private LocalDate issueDate;
    private LocalDate dueDate;
    private InvoiceType invoiceType;
    private BigDecimal subtotal;
    private BigDecimal itbisAmount;
    private BigDecimal discountAmount;
    private BigDecimal totalAmount;
    private BigDecimal netAmount;
    private BigDecimal paidAmount;
    private BigDecimal balanceDue;
    private InvoiceStatus status;
    private String notes;
    private String dgiiTrackId;
    private String dgiiStatus;
    private String ecfPayload; // JSON string
    private String qrHash;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
    private UUID createdBy;
    private UUID updatedBy;

    // Transient fields for relationships
    private Client client;
    private List<InvoiceItem> items;

    public enum InvoiceType {
        CREDITO, CONTADO
    }

    public enum InvoiceStatus {
        PENDING, PAID, OVERDUE, CANCELLED
    }

    public enum NCFType {
        B01("B01"), B02("B02");

        private final String prefix;

        NCFType(String prefix) {
            this.prefix = prefix;
        }

        public String getPrefix() {
            return prefix;
        }
    }
}

===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\data\src\main\java\com\securitybusinesssuite\data\entity\Invoice.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\data\src\main\java\com\securitybusinesssuite\data\entity\InvoiceItem.java =====
// path: data/src/main/java/com/securitybusinesssuite/data/entity/InvoiceItem.java
package com.securitybusinesssuite.data.entity;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.UUID;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class InvoiceItem {
    private UUID id;
    private UUID invoiceId;
    private String serviceCode;
    private String description;
    private Client.SecurityService serviceType;
    private BigDecimal quantity;
    private BigDecimal unitPrice;
    private BigDecimal itbisRate;
    private BigDecimal itbisAmount;
    private BigDecimal discountPercentage;
    private BigDecimal discountAmount;
    private BigDecimal lineSubtotal;
    private BigDecimal lineTotal;
    private LocalDateTime createdAt;
    private UUID createdBy;
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\data\src\main\java\com\securitybusinesssuite\data\entity\InvoiceItem.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\data\src\main\java\com\securitybusinesssuite\data\entity\InvoiceSequence.java =====
// path: data/src/main/java/com/securitybusinesssuite/data/entity/InvoiceSequence.java
package com.securitybusinesssuite.data.entity;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.UUID;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class InvoiceSequence {
    private UUID id;
    private Integer currentNumber;
    private Integer year;
}

===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\data\src\main\java\com\securitybusinesssuite\data\entity\InvoiceSequence.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\data\src\main\java\com\securitybusinesssuite\data\entity\NCFSequence.java =====
// path: data/src/main/java/com/securitybusinesssuite/data/entity/NCFSequence.java
package com.securitybusinesssuite.data.entity;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;
import java.util.UUID;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class NCFSequence {
    private UUID id;
    private Invoice.NCFType ncfType;
    private String prefix;
    private Long currentNumber;
    private Long maxNumber;
    private Integer year;
    private boolean isActive;
    private LocalDateTime createdAt;
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\data\src\main\java\com\securitybusinesssuite\data\entity\NCFSequence.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\data\src\main\java\com\securitybusinesssuite\data\entity\Receipt.java =====
// path: data/src/main/java/com/securitybusinesssuite/data/entity/Receipt.java
package com.securitybusinesssuite.data.entity;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.List;
import java.util.UUID;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class Receipt {
    private UUID id;
    private String receiptNumber;
    private UUID clientId;
    private LocalDate issueDate;
    private BigDecimal totalAmount;
    private Client.PaymentMethod paymentMethod;
    private String currency;
    private String checkNumber;
    private String bankName;
    private String referenceNumber;
    private ReceiptStatus status;
    private String notes;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
    private UUID createdBy;
    private UUID updatedBy;

    // Transient fields for relationships
    private Client client;
    private List<ReceiptAllocation> allocations;

    public enum ReceiptStatus {
        ACTIVE, CANCELLED, VOIDED
    }
}

===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\data\src\main\java\com\securitybusinesssuite\data\entity\Receipt.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\data\src\main\java\com\securitybusinesssuite\data\entity\ReceiptAllocation.java =====
// path: data/src/main/java/com/securitybusinesssuite/data/entity/ReceiptAllocation.java
package com.securitybusinesssuite.data.entity;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.UUID;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ReceiptAllocation {
    private UUID id;
    private UUID receiptId;
    private UUID invoiceId;
    private BigDecimal allocatedAmount;
    private LocalDateTime createdAt;
    private UUID createdBy;

    // Transient fields
    private Invoice invoice;
}

===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\data\src\main\java\com\securitybusinesssuite\data\entity\ReceiptAllocation.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\data\src\main\java\com\securitybusinesssuite\data\entity\ReceiptSequence.java =====
// path: data/src/main/java/com/securitybusinesssuite/data/entity/ReceiptSequence.java
package com.securitybusinesssuite.data.entity;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.UUID;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ReceiptSequence {
    private UUID id;
    private Integer currentNumber;
    private String prefix;
    private Integer year;
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\data\src\main\java\com\securitybusinesssuite\data\entity\ReceiptSequence.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\data\src\main\java\com\securitybusinesssuite\data\entity\User.java =====
// path: data/src/main/java/com/securitybusinesssuite/data/entity/User.java
package com.securitybusinesssuite.data.entity;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;
import java.util.UUID;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class User {
    private UUID id;
    private String email;
    private String passwordHash;
    private String firstName;
    private String lastName;
    private boolean emailVerified;
    private AuthProvider provider;
    private String providerId;
    private String emailVerificationToken;
    private LocalDateTime emailVerificationTokenExpiry;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;

    public enum AuthProvider {
        LOCAL, GOOGLE
    }
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\data\src\main\java\com\securitybusinesssuite\data\entity\User.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\data\src\main\java\com\securitybusinesssuite\data\repository\ClientRepository.java =====
// path: data/src/main/java/com/securitybusinesssuite/data/repository/ClientRepository.java
package com.securitybusinesssuite.data.repository;

import com.securitybusinesssuite.data.entity.Client;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

public interface ClientRepository {
    Client save(Client client);
    Client update(Client client);
    Optional<Client> findById(UUID id);
    Optional<Client> findByClientCode(String clientCode);
    Optional<Client> findByRnc(String rnc);
    List<Client> findByBusinessNameContaining(String businessName);
    List<Client> findByStatus(Client.ClientStatus status);
    List<Client> findByClientType(Client.ClientType clientType);
    Page<Client> findAll(Pageable pageable);
    Page<Client> findByFilters(String businessName, Client.ClientType clientType,
                               Client.ClientStatus status, Client.BusinessSector sector, Pageable pageable);
    boolean existsByRnc(String rnc);
    boolean existsByClientCode(String clientCode);
    long countByStatus(Client.ClientStatus status);
    void deleteById(UUID id);
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\data\src\main\java\com\securitybusinesssuite\data\repository\ClientRepository.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\data\src\main\java\com\securitybusinesssuite\data\repository\impl\ClientRepositoryImpl.java =====
// path: data/src/main/java/com/securitybusinesssuite/data/repository/impl/ClientRepositoryImpl.java
package com.securitybusinesssuite.data.repository.impl;

import com.securitybusinesssuite.data.entity.Client;
import com.securitybusinesssuite.data.repository.ClientRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.Pageable;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.stereotype.Repository;

import java.sql.Array;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Optional;
import java.util.UUID;
import java.util.stream.Collectors;

@Repository
@RequiredArgsConstructor
public class ClientRepositoryImpl implements ClientRepository {

    private final JdbcTemplate jdbcTemplate;

    private static final String INSERT_CLIENT = """
        INSERT INTO clients (id, client_code, rnc, client_type, business_name, contact_person,
                            business_sector, phone, email, street_name, street_number, sector, 
                            provincia, services, has_contract, contract_start_date, contract_end_date,
                            auto_renewal, payment_method, hourly_rate, requires_ncf, requires_rnc,
                            applies_itbis, status, notes, created_at, updated_at, created_by, updated_by)
        VALUES (?, ?, ?, ?::client_type_enum, ?, ?, ?::business_sector_enum, ?, ?, ?, ?, ?, ?, 
                ?::security_service_enum[], ?, ?, ?, ?, ?::payment_method_enum, ?, ?, ?, ?, 
                ?::client_status_enum, ?, ?, ?, ?, ?)
        """;

    private static final String UPDATE_CLIENT = """
        UPDATE clients SET client_code = ?, rnc = ?, client_type = ?::client_type_enum, 
                          business_name = ?, contact_person = ?, business_sector = ?::business_sector_enum,
                          phone = ?, email = ?, street_name = ?, street_number = ?, sector = ?, 
                          provincia = ?, services = ?::security_service_enum[], has_contract = ?,
                          contract_start_date = ?, contract_end_date = ?, auto_renewal = ?,
                          payment_method = ?::payment_method_enum, hourly_rate = ?, requires_ncf = ?,
                          requires_rnc = ?, applies_itbis = ?, status = ?::client_status_enum,
                          notes = ?, updated_at = ?, updated_by = ?
        WHERE id = ?
        """;

    private static final String SELECT_BASE = """
        SELECT id, client_code, rnc, client_type, business_name, contact_person, business_sector,
               phone, email, street_name, street_number, sector, provincia, services, has_contract,
               contract_start_date, contract_end_date, auto_renewal, payment_method, hourly_rate,
               requires_ncf, requires_rnc, applies_itbis, status, notes, created_at, updated_at,
               created_by, updated_by
        FROM clients
        """;

    private static final String SELECT_BY_ID = SELECT_BASE + " WHERE id = ?";
    private static final String SELECT_BY_CLIENT_CODE = SELECT_BASE + " WHERE client_code = ?";
    private static final String SELECT_BY_RNC = SELECT_BASE + " WHERE rnc = ?";
    private static final String SELECT_BY_STATUS = SELECT_BASE + " WHERE status = ?::client_status_enum";
    private static final String SELECT_BY_TYPE = SELECT_BASE + " WHERE client_type = ?::client_type_enum";
    private static final String SELECT_BY_BUSINESS_NAME = SELECT_BASE + " WHERE LOWER(business_name) LIKE LOWER(?)";

    private static final String EXISTS_BY_RNC = "SELECT EXISTS(SELECT 1 FROM clients WHERE rnc = ?)";
    private static final String EXISTS_BY_CLIENT_CODE = "SELECT EXISTS(SELECT 1 FROM clients WHERE client_code = ?)";
    private static final String COUNT_BY_STATUS = "SELECT COUNT(*) FROM clients WHERE status = ?::client_status_enum";
    private static final String DELETE_BY_ID = "DELETE FROM clients WHERE id = ?";

    private final ClientRowMapper clientRowMapper = new ClientRowMapper();

    @Override
    public Client save(Client client) {
        client.setId(UUID.randomUUID());
        client.setCreatedAt(LocalDateTime.now());
        client.setUpdatedAt(LocalDateTime.now());

        jdbcTemplate.update(INSERT_CLIENT,
                client.getId(),
                client.getClientCode(),
                client.getRnc(),
                client.getClientType() != null ? client.getClientType().name() : null,
                client.getBusinessName(),
                client.getContactPerson(),
                client.getBusinessSector() != null ? client.getBusinessSector().name() : null,
                client.getPhone(),
                client.getEmail(),
                client.getStreetName(),
                client.getStreetNumber(),
                client.getSector(),
                client.getProvincia(),
                client.getServices() != null ?
                        client.getServices().stream().map(Enum::name).toArray(String[]::new) : null,
                client.isHasContract(),
                client.getContractStartDate(),
                client.getContractEndDate(),
                client.isAutoRenewal(),
                client.getPaymentMethod() != null ? client.getPaymentMethod().name() : null,
                client.getHourlyRate(),
                client.isRequiresNcf(),
                client.isRequiresRnc(),
                client.isAppliesItbis(),
                client.getStatus() != null ? client.getStatus().name() : null,
                client.getNotes(),
                Timestamp.valueOf(client.getCreatedAt()),
                Timestamp.valueOf(client.getUpdatedAt()),
                client.getCreatedBy(),
                client.getUpdatedBy()
        );

        return client;
    }

    @Override
    public Client update(Client client) {
        client.setUpdatedAt(LocalDateTime.now());

        jdbcTemplate.update(UPDATE_CLIENT,
                client.getClientCode(),
                client.getRnc(),
                client.getClientType() != null ? client.getClientType().name() : null,
                client.getBusinessName(),
                client.getContactPerson(),
                client.getBusinessSector() != null ? client.getBusinessSector().name() : null,
                client.getPhone(),
                client.getEmail(),
                client.getStreetName(),
                client.getStreetNumber(),
                client.getSector(),
                client.getProvincia(),
                client.getServices() != null ?
                        client.getServices().stream().map(Enum::name).toArray(String[]::new) : null,
                client.isHasContract(),
                client.getContractStartDate(),
                client.getContractEndDate(),
                client.isAutoRenewal(),
                client.getPaymentMethod() != null ? client.getPaymentMethod().name() : null,
                client.getHourlyRate(),
                client.isRequiresNcf(),
                client.isRequiresRnc(),
                client.isAppliesItbis(),
                client.getStatus() != null ? client.getStatus().name() : null,
                client.getNotes(),
                Timestamp.valueOf(client.getUpdatedAt()),
                client.getUpdatedBy(),
                client.getId()
        );

        return client;
    }

    @Override
    public Optional<Client> findById(UUID id) {
        return jdbcTemplate.query(SELECT_BY_ID, clientRowMapper, id)
                .stream().findFirst();
    }

    @Override
    public Optional<Client> findByClientCode(String clientCode) {
        return jdbcTemplate.query(SELECT_BY_CLIENT_CODE, clientRowMapper, clientCode)
                .stream().findFirst();
    }

    @Override
    public Optional<Client> findByRnc(String rnc) {
        return jdbcTemplate.query(SELECT_BY_RNC, clientRowMapper, rnc)
                .stream().findFirst();
    }

    @Override
    public List<Client> findByBusinessNameContaining(String businessName) {
        return jdbcTemplate.query(SELECT_BY_BUSINESS_NAME, clientRowMapper, "%" + businessName + "%");
    }

    @Override
    public List<Client> findByStatus(Client.ClientStatus status) {
        return jdbcTemplate.query(SELECT_BY_STATUS, clientRowMapper, status.name());
    }

    @Override
    public List<Client> findByClientType(Client.ClientType clientType) {
        return jdbcTemplate.query(SELECT_BY_TYPE, clientRowMapper, clientType.name());
    }

    @Override
    public Page<Client> findAll(Pageable pageable) {
        String sql = SELECT_BASE + " ORDER BY created_at DESC LIMIT ? OFFSET ?";
        List<Client> clients = jdbcTemplate.query(sql, clientRowMapper,
                pageable.getPageSize(), pageable.getOffset());

        long total = jdbcTemplate.queryForObject("SELECT COUNT(*) FROM clients", Long.class);
        return new PageImpl<>(clients, pageable, total);
    }

    @Override
    public Page<Client> findByFilters(String businessName, Client.ClientType clientType,
                                      Client.ClientStatus status, Client.BusinessSector sector,
                                      Pageable pageable) {
        StringBuilder sql = new StringBuilder(SELECT_BASE + " WHERE 1=1");
        List<Object> params = new ArrayList<>();

        if (businessName != null && !businessName.trim().isEmpty()) {
            sql.append(" AND LOWER(business_name) LIKE LOWER(?)");
            params.add("%" + businessName.trim() + "%");
        }

        if (clientType != null) {
            sql.append(" AND client_type = ?::client_type_enum");
            params.add(clientType.name());
        }

        if (status != null) {
            sql.append(" AND status = ?::client_status_enum");
            params.add(status.name());
        }

        if (sector != null) {
            sql.append(" AND business_sector = ?::business_sector_enum");
            params.add(sector.name());
        }

        sql.append(" ORDER BY created_at DESC LIMIT ? OFFSET ?");
        params.add(pageable.getPageSize());
        params.add(pageable.getOffset());

        List<Client> clients = jdbcTemplate.query(sql.toString(), clientRowMapper, params.toArray());

        // Count query for total
        String countSql = sql.toString().replace(SELECT_BASE, "SELECT COUNT(*)").split(" ORDER BY")[0];
        long total = jdbcTemplate.queryForObject(countSql, Long.class,
                params.subList(0, params.size() - 2).toArray());

        return new PageImpl<>(clients, pageable, total);
    }

    @Override
    public boolean existsByRnc(String rnc) {
        Boolean exists = jdbcTemplate.queryForObject(EXISTS_BY_RNC, Boolean.class, rnc);
        return exists != null && exists;
    }

    @Override
    public boolean existsByClientCode(String clientCode) {
        Boolean exists = jdbcTemplate.queryForObject(EXISTS_BY_CLIENT_CODE, Boolean.class, clientCode);
        return exists != null && exists;
    }

    @Override
    public long countByStatus(Client.ClientStatus status) {
        Long count = jdbcTemplate.queryForObject(COUNT_BY_STATUS, Long.class, status.name());
        return count != null ? count : 0;
    }

    @Override
    public void deleteById(UUID id) {
        jdbcTemplate.update(DELETE_BY_ID, id);
    }

    private static class ClientRowMapper implements RowMapper<Client> {
        @Override
        public Client mapRow(ResultSet rs, int rowNum) throws SQLException {
            // Parse services array
            List<Client.SecurityService> services = new ArrayList<>();
            Array servicesArray = rs.getArray("services");
            if (servicesArray != null) {
                String[] serviceNames = (String[]) servicesArray.getArray();
                services = Arrays.stream(serviceNames)
                        .map(Client.SecurityService::valueOf)
                        .collect(Collectors.toList());
            }

            return Client.builder()
                    .id(UUID.fromString(rs.getString("id")))
                    .clientCode(rs.getString("client_code"))
                    .rnc(rs.getString("rnc"))
                    .clientType(rs.getString("client_type") != null ?
                            Client.ClientType.valueOf(rs.getString("client_type")) : null)
                    .businessName(rs.getString("business_name"))
                    .contactPerson(rs.getString("contact_person"))
                    .businessSector(rs.getString("business_sector") != null ?
                            Client.BusinessSector.valueOf(rs.getString("business_sector")) : null)
                    .phone(rs.getString("phone"))
                    .email(rs.getString("email"))
                    .streetName(rs.getString("street_name"))
                    .streetNumber(rs.getString("street_number"))
                    .sector(rs.getString("sector"))
                    .provincia(rs.getString("provincia"))
                    .services(services)
                    .hasContract(rs.getBoolean("has_contract"))
                    .contractStartDate(rs.getDate("contract_start_date") != null ?
                            rs.getDate("contract_start_date").toLocalDate() : null)
                    .contractEndDate(rs.getDate("contract_end_date") != null ?
                            rs.getDate("contract_end_date").toLocalDate() : null)
                    .autoRenewal(rs.getBoolean("auto_renewal"))
                    .paymentMethod(rs.getString("payment_method") != null ?
                            Client.PaymentMethod.valueOf(rs.getString("payment_method")) : null)
                    .hourlyRate(rs.getBigDecimal("hourly_rate"))
                    .requiresNcf(rs.getBoolean("requires_ncf"))
                    .requiresRnc(rs.getBoolean("requires_rnc"))
                    .appliesItbis(rs.getBoolean("applies_itbis"))
                    .status(rs.getString("status") != null ?
                            Client.ClientStatus.valueOf(rs.getString("status")) : null)
                    .notes(rs.getString("notes"))
                    .createdAt(rs.getTimestamp("created_at") != null ?
                            rs.getTimestamp("created_at").toLocalDateTime() : null)
                    .updatedAt(rs.getTimestamp("updated_at") != null ?
                            rs.getTimestamp("updated_at").toLocalDateTime() : null)
                    .createdBy(rs.getString("created_by") != null ?
                            UUID.fromString(rs.getString("created_by")) : null)
                    .updatedBy(rs.getString("updated_by") != null ?
                            UUID.fromString(rs.getString("updated_by")) : null)
                    .build();
        }
    }
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\data\src\main\java\com\securitybusinesssuite\data\repository\impl\ClientRepositoryImpl.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\data\src\main\java\com\securitybusinesssuite\data\repository\impl\InvoiceItemRepositoryImpl.java =====
// path: data/src/main/java/com/securitybusinesssuite/data/repository/impl/InvoiceItemRepositoryImpl.java
package com.securitybusinesssuite.data.repository.impl;

import com.securitybusinesssuite.data.entity.Client;
import com.securitybusinesssuite.data.entity.InvoiceItem;
import com.securitybusinesssuite.data.repository.InvoiceItemRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.stereotype.Repository;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

@Repository
@RequiredArgsConstructor
public class InvoiceItemRepositoryImpl implements InvoiceItemRepository {

    private final JdbcTemplate jdbcTemplate;

    private static final String INSERT_ITEM = """
        INSERT INTO invoice_items (id, invoice_id, service_code, description, service_type,
                                  quantity, unit_price, itbis_rate, itbis_amount, discount_percentage,
                                  discount_amount, line_subtotal, line_total, created_at, created_by)
        VALUES (?, ?, ?, ?, ?::security_service_enum, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        """;

    private static final String UPDATE_ITEM = """
        UPDATE invoice_items SET service_code = ?, description = ?, service_type = ?::security_service_enum,
                                quantity = ?, unit_price = ?, itbis_rate = ?, itbis_amount = ?,
                                discount_percentage = ?, discount_amount = ?, line_subtotal = ?, line_total = ?
        WHERE id = ?
        """;

    private static final String SELECT_BASE = """
        SELECT id, invoice_id, service_code, description, service_type, quantity, unit_price,
               itbis_rate, itbis_amount, discount_percentage, discount_amount, line_subtotal,
               line_total, created_at, created_by
        FROM invoice_items
        """;

    private static final String SELECT_BY_ID = SELECT_BASE + " WHERE id = ?";
    private static final String SELECT_BY_INVOICE_ID = SELECT_BASE + " WHERE invoice_id = ? ORDER BY created_at";
    private static final String DELETE_BY_ID = "DELETE FROM invoice_items WHERE id = ?";
    private static final String DELETE_BY_INVOICE_ID = "DELETE FROM invoice_items WHERE invoice_id = ?";

    private final InvoiceItemRowMapper itemRowMapper = new InvoiceItemRowMapper();

    @Override
    public InvoiceItem save(InvoiceItem item) {
        item.setId(UUID.randomUUID());
        item.setCreatedAt(LocalDateTime.now());

        jdbcTemplate.update(INSERT_ITEM,
                item.getId(),
                item.getInvoiceId(),
                item.getServiceCode(),
                item.getDescription(),
                item.getServiceType() != null ? item.getServiceType().name() : null,
                item.getQuantity(),
                item.getUnitPrice(),
                item.getItbisRate(),
                item.getItbisAmount(),
                item.getDiscountPercentage(),
                item.getDiscountAmount(),
                item.getLineSubtotal(),
                item.getLineTotal(),
                Timestamp.valueOf(item.getCreatedAt()),
                item.getCreatedBy()
        );

        return item;
    }

    @Override
    public InvoiceItem update(InvoiceItem item) {
        jdbcTemplate.update(UPDATE_ITEM,
                item.getServiceCode(),
                item.getDescription(),
                item.getServiceType() != null ? item.getServiceType().name() : null,
                item.getQuantity(),
                item.getUnitPrice(),
                item.getItbisRate(),
                item.getItbisAmount(),
                item.getDiscountPercentage(),
                item.getDiscountAmount(),
                item.getLineSubtotal(),
                item.getLineTotal(),
                item.getId()
        );

        return item;
    }

    @Override
    public Optional<InvoiceItem> findById(UUID id) {
        return jdbcTemplate.query(SELECT_BY_ID, itemRowMapper, id).stream().findFirst();
    }

    @Override
    public List<InvoiceItem> findByInvoiceId(UUID invoiceId) {
        return jdbcTemplate.query(SELECT_BY_INVOICE_ID, itemRowMapper, invoiceId);
    }

    @Override
    public void deleteById(UUID id) {
        jdbcTemplate.update(DELETE_BY_ID, id);
    }

    @Override
    public void deleteByInvoiceId(UUID invoiceId) {
        jdbcTemplate.update(DELETE_BY_INVOICE_ID, invoiceId);
    }

    private static class InvoiceItemRowMapper implements RowMapper<InvoiceItem> {
        @Override
        public InvoiceItem mapRow(ResultSet rs, int rowNum) throws SQLException {
            return InvoiceItem.builder()
                    .id(UUID.fromString(rs.getString("id")))
                    .invoiceId(UUID.fromString(rs.getString("invoice_id")))
                    .serviceCode(rs.getString("service_code"))
                    .description(rs.getString("description"))
                    .serviceType(rs.getString("service_type") != null ?
                            Client.SecurityService.valueOf(rs.getString("service_type")) : null)
                    .quantity(rs.getBigDecimal("quantity"))
                    .unitPrice(rs.getBigDecimal("unit_price"))
                    .itbisRate(rs.getBigDecimal("itbis_rate"))
                    .itbisAmount(rs.getBigDecimal("itbis_amount"))
                    .discountPercentage(rs.getBigDecimal("discount_percentage"))
                    .discountAmount(rs.getBigDecimal("discount_amount"))
                    .lineSubtotal(rs.getBigDecimal("line_subtotal"))
                    .lineTotal(rs.getBigDecimal("line_total"))
                    .createdAt(rs.getTimestamp("created_at") != null ?
                            rs.getTimestamp("created_at").toLocalDateTime() : null)
                    .createdBy(rs.getString("created_by") != null ?
                            UUID.fromString(rs.getString("created_by")) : null)
                    .build();
        }
    }
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\data\src\main\java\com\securitybusinesssuite\data\repository\impl\InvoiceItemRepositoryImpl.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\data\src\main\java\com\securitybusinesssuite\data\repository\impl\InvoiceRepositoryImpl.java =====
// path: data/src/main/java/com/securitybusinesssuite/data/repository/impl/InvoiceRepositoryImpl.java
package com.securitybusinesssuite.data.repository.impl;

import com.securitybusinesssuite.data.entity.Invoice;
import com.securitybusinesssuite.data.repository.InvoiceRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.Pageable;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.stereotype.Repository;

import java.math.BigDecimal;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

@Repository
@RequiredArgsConstructor
public class InvoiceRepositoryImpl implements InvoiceRepository {

    private final JdbcTemplate jdbcTemplate;

    private static final String INSERT_INVOICE = """
        INSERT INTO invoices (id, invoice_number, ncf, ncf_type, client_id, issue_date, due_date,
                             invoice_type, subtotal, itbis_amount, discount_amount, total_amount,
                             net_amount, paid_amount, balance_due, status, notes, dgii_track_id,
                             dgii_status, ecf_payload, qr_hash, created_at, updated_at, created_by, updated_by)
        VALUES (?, ?, ?, ?::ncf_type_enum, ?, ?, ?, ?::invoice_type_enum, ?, ?, ?, ?, ?, ?, ?, 
                ?::invoice_status_enum, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        """;

    private static final String UPDATE_INVOICE = """
        UPDATE invoices SET invoice_number = ?, ncf = ?, ncf_type = ?::ncf_type_enum, client_id = ?,
                           issue_date = ?, due_date = ?, invoice_type = ?::invoice_type_enum,
                           subtotal = ?, itbis_amount = ?, discount_amount = ?, total_amount = ?,
                           net_amount = ?, paid_amount = ?, balance_due = ?, status = ?::invoice_status_enum,
                           notes = ?, dgii_track_id = ?, dgii_status = ?, ecf_payload = ?, qr_hash = ?,
                           updated_at = ?, updated_by = ?
        WHERE id = ?
        """;

    private static final String SELECT_BASE = """
        SELECT id, invoice_number, ncf, ncf_type, client_id, issue_date, due_date, invoice_type,
               subtotal, itbis_amount, discount_amount, total_amount, net_amount, paid_amount,
               balance_due, status, notes, dgii_track_id, dgii_status, ecf_payload, qr_hash,
               created_at, updated_at, created_by, updated_by
        FROM invoices
        """;

    private static final String SELECT_BY_ID = SELECT_BASE + " WHERE id = ?";
    private static final String SELECT_BY_INVOICE_NUMBER = SELECT_BASE + " WHERE invoice_number = ?";
    private static final String SELECT_BY_NCF = SELECT_BASE + " WHERE ncf = ?";
    private static final String SELECT_BY_CLIENT_ID = SELECT_BASE + " WHERE client_id = ?";
    private static final String SELECT_BY_STATUS = SELECT_BASE + " WHERE status = ?::invoice_status_enum";
    private static final String SELECT_OVERDUE = SELECT_BASE + " WHERE status = 'PENDING' AND due_date < CURRENT_DATE";
    private static final String SELECT_BY_STATUS_AND_DUE_DATE = SELECT_BASE + " WHERE status = ?::invoice_status_enum AND due_date < ?";

    private static final String EXISTS_BY_INVOICE_NUMBER = "SELECT EXISTS(SELECT 1 FROM invoices WHERE invoice_number = ?)";
    private static final String EXISTS_BY_NCF = "SELECT EXISTS(SELECT 1 FROM invoices WHERE ncf = ?)";
    private static final String SUM_BY_CLIENT_AND_STATUS = "SELECT COALESCE(SUM(total_amount), 0) FROM invoices WHERE client_id = ? AND status = ?::invoice_status_enum";
    private static final String COUNT_BY_STATUS = "SELECT COUNT(*) FROM invoices WHERE status = ?::invoice_status_enum";
    private static final String DELETE_BY_ID = "DELETE FROM invoices WHERE id = ?";

    private final InvoiceRowMapper invoiceRowMapper = new InvoiceRowMapper();

    @Override
    public Invoice save(Invoice invoice) {
        invoice.setId(UUID.randomUUID());
        invoice.setCreatedAt(LocalDateTime.now());
        invoice.setUpdatedAt(LocalDateTime.now());

        jdbcTemplate.update(INSERT_INVOICE,
                invoice.getId(),
                invoice.getInvoiceNumber(),
                invoice.getNcf(),
                invoice.getNcfType() != null ? invoice.getNcfType().name() : null,
                invoice.getClientId(),
                invoice.getIssueDate(),
                invoice.getDueDate(),
                invoice.getInvoiceType() != null ? invoice.getInvoiceType().name() : null,
                invoice.getSubtotal(),
                invoice.getItbisAmount(),
                invoice.getDiscountAmount(),
                invoice.getTotalAmount(),
                invoice.getNetAmount(),
                invoice.getPaidAmount(),
                invoice.getBalanceDue(),
                invoice.getStatus() != null ? invoice.getStatus().name() : null,
                invoice.getNotes(),
                invoice.getDgiiTrackId(),
                invoice.getDgiiStatus(),
                invoice.getEcfPayload(),
                invoice.getQrHash(),
                Timestamp.valueOf(invoice.getCreatedAt()),
                Timestamp.valueOf(invoice.getUpdatedAt()),
                invoice.getCreatedBy(),
                invoice.getUpdatedBy()
        );

        return invoice;
    }

    @Override
    public Invoice update(Invoice invoice) {
        invoice.setUpdatedAt(LocalDateTime.now());

        jdbcTemplate.update(UPDATE_INVOICE,
                invoice.getInvoiceNumber(),
                invoice.getNcf(),
                invoice.getNcfType() != null ? invoice.getNcfType().name() : null,
                invoice.getClientId(),
                invoice.getIssueDate(),
                invoice.getDueDate(),
                invoice.getInvoiceType() != null ? invoice.getInvoiceType().name() : null,
                invoice.getSubtotal(),
                invoice.getItbisAmount(),
                invoice.getDiscountAmount(),
                invoice.getTotalAmount(),
                invoice.getNetAmount(),
                invoice.getPaidAmount(),
                invoice.getBalanceDue(),
                invoice.getStatus() != null ? invoice.getStatus().name() : null,
                invoice.getNotes(),
                invoice.getDgiiTrackId(),
                invoice.getDgiiStatus(),
                invoice.getEcfPayload(),
                invoice.getQrHash(),
                Timestamp.valueOf(invoice.getUpdatedAt()),
                invoice.getUpdatedBy(),
                invoice.getId()
        );

        return invoice;
    }

    @Override
    public Optional<Invoice> findById(UUID id) {
        return jdbcTemplate.query(SELECT_BY_ID, invoiceRowMapper, id).stream().findFirst();
    }

    @Override
    public Optional<Invoice> findByInvoiceNumber(String invoiceNumber) {
        return jdbcTemplate.query(SELECT_BY_INVOICE_NUMBER, invoiceRowMapper, invoiceNumber).stream().findFirst();
    }

    @Override
    public Optional<Invoice> findByNcf(String ncf) {
        return jdbcTemplate.query(SELECT_BY_NCF, invoiceRowMapper, ncf).stream().findFirst();
    }

    @Override
    public List<Invoice> findByClientId(UUID clientId) {
        return jdbcTemplate.query(SELECT_BY_CLIENT_ID, invoiceRowMapper, clientId);
    }

    @Override
    public List<Invoice> findByStatus(Invoice.InvoiceStatus status) {
        return jdbcTemplate.query(SELECT_BY_STATUS, invoiceRowMapper, status.name());
    }

    @Override
    public List<Invoice> findByStatusAndDueDateBefore(Invoice.InvoiceStatus status, LocalDate date) {
        return jdbcTemplate.query(SELECT_BY_STATUS_AND_DUE_DATE, invoiceRowMapper, status.name(), date);
    }

    @Override
    public List<Invoice> findOverdueInvoices() {
        return jdbcTemplate.query(SELECT_OVERDUE, invoiceRowMapper);
    }

    @Override
    public Page<Invoice> findAll(Pageable pageable) {
        String sql = SELECT_BASE + " ORDER BY created_at DESC LIMIT ? OFFSET ?";
        List<Invoice> invoices = jdbcTemplate.query(sql, invoiceRowMapper,
                pageable.getPageSize(), pageable.getOffset());

        long total = jdbcTemplate.queryForObject("SELECT COUNT(*) FROM invoices", Long.class);
        return new PageImpl<>(invoices, pageable, total);
    }

    @Override
    public Page<Invoice> findByFilters(UUID clientId, Invoice.InvoiceStatus status,
                                       LocalDate fromDate, LocalDate toDate,
                                       BigDecimal minAmount, BigDecimal maxAmount, Pageable pageable) {
        StringBuilder sql = new StringBuilder(SELECT_BASE + " WHERE 1=1");
        List<Object> params = new ArrayList<>();

        if (clientId != null) {
            sql.append(" AND client_id = ?");
            params.add(clientId);
        }

        if (status != null) {
            sql.append(" AND status = ?::invoice_status_enum");
            params.add(status.name());
        }

        if (fromDate != null) {
            sql.append(" AND issue_date >= ?");
            params.add(fromDate);
        }

        if (toDate != null) {
            sql.append(" AND issue_date <= ?");
            params.add(toDate);
        }

        if (minAmount != null) {
            sql.append(" AND total_amount >= ?");
            params.add(minAmount);
        }

        if (maxAmount != null) {
            sql.append(" AND total_amount <= ?");
            params.add(maxAmount);
        }

        sql.append(" ORDER BY created_at DESC LIMIT ? OFFSET ?");
        params.add(pageable.getPageSize());
        params.add(pageable.getOffset());

        List<Invoice> invoices = jdbcTemplate.query(sql.toString(), invoiceRowMapper, params.toArray());

        // Count query for total
        String countSql = sql.toString().replace(SELECT_BASE, "SELECT COUNT(*)").split(" ORDER BY")[0];
        long total = jdbcTemplate.queryForObject(countSql, Long.class,
                params.subList(0, params.size() - 2).toArray());

        return new PageImpl<>(invoices, pageable, total);
    }

    @Override
    public boolean existsByInvoiceNumber(String invoiceNumber) {
        Boolean exists = jdbcTemplate.queryForObject(EXISTS_BY_INVOICE_NUMBER, Boolean.class, invoiceNumber);
        return exists != null && exists;
    }

    @Override
    public boolean existsByNcf(String ncf) {
        Boolean exists = jdbcTemplate.queryForObject(EXISTS_BY_NCF, Boolean.class, ncf);
        return exists != null && exists;
    }

    @Override
    public BigDecimal getTotalByClientAndStatus(UUID clientId, Invoice.InvoiceStatus status) {
        return jdbcTemplate.queryForObject(SUM_BY_CLIENT_AND_STATUS, BigDecimal.class, clientId, status.name());
    }

    @Override
    public long countByStatus(Invoice.InvoiceStatus status) {
        Long count = jdbcTemplate.queryForObject(COUNT_BY_STATUS, Long.class, status.name());
        return count != null ? count : 0;
    }

    @Override
    public void deleteById(UUID id) {
        jdbcTemplate.update(DELETE_BY_ID, id);
    }

    private static class InvoiceRowMapper implements RowMapper<Invoice> {
        @Override
        public Invoice mapRow(ResultSet rs, int rowNum) throws SQLException {
            return Invoice.builder()
                    .id(UUID.fromString(rs.getString("id")))
                    .invoiceNumber(rs.getString("invoice_number"))
                    .ncf(rs.getString("ncf"))
                    .ncfType(rs.getString("ncf_type") != null ?
                            Invoice.NCFType.valueOf(rs.getString("ncf_type")) : null)
                    .clientId(UUID.fromString(rs.getString("client_id")))
                    .issueDate(rs.getDate("issue_date") != null ?
                            rs.getDate("issue_date").toLocalDate() : null)
                    .dueDate(rs.getDate("due_date") != null ?
                            rs.getDate("due_date").toLocalDate() : null)
                    .invoiceType(rs.getString("invoice_type") != null ?
                            Invoice.InvoiceType.valueOf(rs.getString("invoice_type")) : null)
                    .subtotal(rs.getBigDecimal("subtotal"))
                    .itbisAmount(rs.getBigDecimal("itbis_amount"))
                    .discountAmount(rs.getBigDecimal("discount_amount"))
                    .totalAmount(rs.getBigDecimal("total_amount"))
                    .netAmount(rs.getBigDecimal("net_amount"))
                    .paidAmount(rs.getBigDecimal("paid_amount"))
                    .balanceDue(rs.getBigDecimal("balance_due"))
                    .status(rs.getString("status") != null ?
                            Invoice.InvoiceStatus.valueOf(rs.getString("status")) : null)
                    .notes(rs.getString("notes"))
                    .dgiiTrackId(rs.getString("dgii_track_id"))
                    .dgiiStatus(rs.getString("dgii_status"))
                    .ecfPayload(rs.getString("ecf_payload"))
                    .qrHash(rs.getString("qr_hash"))
                    .createdAt(rs.getTimestamp("created_at") != null ?
                            rs.getTimestamp("created_at").toLocalDateTime() : null)
                    .updatedAt(rs.getTimestamp("updated_at") != null ?
                            rs.getTimestamp("updated_at").toLocalDateTime() : null)
                    .createdBy(rs.getString("created_by") != null ?
                            UUID.fromString(rs.getString("created_by")) : null)
                    .updatedBy(rs.getString("updated_by") != null ?
                            UUID.fromString(rs.getString("updated_by")) : null)
                    .build();
        }
    }
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\data\src\main\java\com\securitybusinesssuite\data\repository\impl\InvoiceRepositoryImpl.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\data\src\main\java\com\securitybusinesssuite\data\repository\impl\ReceiptAllocationRepositoryImpl.java =====
// path: data/src/main/java/com/securitybusinesssuite/data/repository/impl/ReceiptAllocationRepositoryImpl.java
package com.securitybusinesssuite.data.repository.impl;

import com.securitybusinesssuite.data.entity.ReceiptAllocation;
import com.securitybusinesssuite.data.repository.ReceiptAllocationRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.stereotype.Repository;

import java.math.BigDecimal;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

@Repository
@RequiredArgsConstructor
public class ReceiptAllocationRepositoryImpl implements ReceiptAllocationRepository {

    private final JdbcTemplate jdbcTemplate;

    private static final String INSERT_ALLOCATION = """
        INSERT INTO receipt_allocations (id, receipt_id, invoice_id, allocated_amount, created_at, created_by)
        VALUES (?, ?, ?, ?, ?, ?)
        """;

    private static final String SELECT_BASE = """
        SELECT id, receipt_id, invoice_id, allocated_amount, created_at, created_by
        FROM receipt_allocations
        """;

    private static final String SELECT_BY_ID = SELECT_BASE + " WHERE id = ?";
    private static final String SELECT_BY_RECEIPT_ID = SELECT_BASE + " WHERE receipt_id = ?";
    private static final String SELECT_BY_INVOICE_ID = SELECT_BASE + " WHERE invoice_id = ?";

    private static final String SUM_BY_RECEIPT_ID = "SELECT COALESCE(SUM(allocated_amount), 0) FROM receipt_allocations WHERE receipt_id = ?";
    private static final String SUM_BY_INVOICE_ID = "SELECT COALESCE(SUM(allocated_amount), 0) FROM receipt_allocations WHERE invoice_id = ?";

    private static final String DELETE_BY_ID = "DELETE FROM receipt_allocations WHERE id = ?";
    private static final String DELETE_BY_RECEIPT_ID = "DELETE FROM receipt_allocations WHERE receipt_id = ?";

    private final ReceiptAllocationRowMapper allocationRowMapper = new ReceiptAllocationRowMapper();

    @Override
    public ReceiptAllocation save(ReceiptAllocation allocation) {
        allocation.setId(UUID.randomUUID());
        allocation.setCreatedAt(LocalDateTime.now());

        jdbcTemplate.update(INSERT_ALLOCATION,
                allocation.getId(),
                allocation.getReceiptId(),
                allocation.getInvoiceId(),
                allocation.getAllocatedAmount(),
                Timestamp.valueOf(allocation.getCreatedAt()),
                allocation.getCreatedBy()
        );

        return allocation;
    }

    @Override
    public Optional<ReceiptAllocation> findById(UUID id) {
        return jdbcTemplate.query(SELECT_BY_ID, allocationRowMapper, id).stream().findFirst();
    }

    @Override
    public List<ReceiptAllocation> findByReceiptId(UUID receiptId) {
        return jdbcTemplate.query(SELECT_BY_RECEIPT_ID, allocationRowMapper, receiptId);
    }

    @Override
    public List<ReceiptAllocation> findByInvoiceId(UUID invoiceId) {
        return jdbcTemplate.query(SELECT_BY_INVOICE_ID, allocationRowMapper, invoiceId);
    }

    @Override
    public BigDecimal getTotalAllocatedByReceiptId(UUID receiptId) {
        return jdbcTemplate.queryForObject(SUM_BY_RECEIPT_ID, BigDecimal.class, receiptId);
    }

    @Override
    public BigDecimal getTotalAllocatedByInvoiceId(UUID invoiceId) {
        return jdbcTemplate.queryForObject(SUM_BY_INVOICE_ID, BigDecimal.class, invoiceId);
    }

    @Override
    public void deleteById(UUID id) {
        jdbcTemplate.update(DELETE_BY_ID, id);
    }

    @Override
    public void deleteByReceiptId(UUID receiptId) {
        jdbcTemplate.update(DELETE_BY_RECEIPT_ID, receiptId);
    }

    private static class ReceiptAllocationRowMapper implements RowMapper<ReceiptAllocation> {
        @Override
        public ReceiptAllocation mapRow(ResultSet rs, int rowNum) throws SQLException {
            return ReceiptAllocation.builder()
                    .id(UUID.fromString(rs.getString("id")))
                    .receiptId(UUID.fromString(rs.getString("receipt_id")))
                    .invoiceId(UUID.fromString(rs.getString("invoice_id")))
                    .allocatedAmount(rs.getBigDecimal("allocated_amount"))
                    .createdAt(rs.getTimestamp("created_at") != null ?
                            rs.getTimestamp("created_at").toLocalDateTime() : null)
                    .createdBy(rs.getString("created_by") != null ?
                            UUID.fromString(rs.getString("created_by")) : null)
                    .build();
        }
    }
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\data\src\main\java\com\securitybusinesssuite\data\repository\impl\ReceiptAllocationRepositoryImpl.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\data\src\main\java\com\securitybusinesssuite\data\repository\impl\ReceiptRepositoryImpl.java =====
// path: data/src/main/java/com/securitybusinesssuite/data/repository/impl/ReceiptRepositoryImpl.java
package com.securitybusinesssuite.data.repository.impl;

import com.securitybusinesssuite.data.entity.Client;
import com.securitybusinesssuite.data.entity.Receipt;
import com.securitybusinesssuite.data.repository.ReceiptRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.Pageable;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.stereotype.Repository;

import java.math.BigDecimal;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

@Repository
@RequiredArgsConstructor
public class ReceiptRepositoryImpl implements ReceiptRepository {

    private final JdbcTemplate jdbcTemplate;

    private static final String INSERT_RECEIPT = """
        INSERT INTO receipts (id, receipt_number, client_id, issue_date, total_amount, payment_method,
                             currency, check_number, bank_name, reference_number, status, notes,
                             created_at, updated_at, created_by, updated_by)
        VALUES (?, ?, ?, ?, ?, ?::payment_method_enum, ?, ?, ?, ?, ?::receipt_status_enum, ?, ?, ?, ?, ?)
        """;

    private static final String UPDATE_RECEIPT = """
        UPDATE receipts SET receipt_number = ?, client_id = ?, issue_date = ?, total_amount = ?,
                           payment_method = ?::payment_method_enum, currency = ?, check_number = ?,
                           bank_name = ?, reference_number = ?, status = ?::receipt_status_enum,
                           notes = ?, updated_at = ?, updated_by = ?
        WHERE id = ?
        """;

    private static final String SELECT_BASE = """
        SELECT id, receipt_number, client_id, issue_date, total_amount, payment_method, currency,
               check_number, bank_name, reference_number, status, notes, created_at, updated_at,
               created_by, updated_by
        FROM receipts
        """;

    private static final String SELECT_BY_ID = SELECT_BASE + " WHERE id = ?";
    private static final String SELECT_BY_RECEIPT_NUMBER = SELECT_BASE + " WHERE receipt_number = ?";
    private static final String SELECT_BY_CLIENT_ID = SELECT_BASE + " WHERE client_id = ?";
    private static final String SELECT_BY_STATUS = SELECT_BASE + " WHERE status = ?::receipt_status_enum";

    private static final String EXISTS_BY_RECEIPT_NUMBER = "SELECT EXISTS(SELECT 1 FROM receipts WHERE receipt_number = ?)";
    private static final String SUM_BY_CLIENT_ID = "SELECT COALESCE(SUM(total_amount), 0) FROM receipts WHERE client_id = ? AND status = 'ACTIVE'";
    private static final String DELETE_BY_ID = "DELETE FROM receipts WHERE id = ?";

    private final ReceiptRowMapper receiptRowMapper = new ReceiptRowMapper();

    @Override
    public Receipt save(Receipt receipt) {
        receipt.setId(UUID.randomUUID());
        receipt.setCreatedAt(LocalDateTime.now());
        receipt.setUpdatedAt(LocalDateTime.now());

        jdbcTemplate.update(INSERT_RECEIPT,
                receipt.getId(),
                receipt.getReceiptNumber(),
                receipt.getClientId(),
                receipt.getIssueDate(),
                receipt.getTotalAmount(),
                receipt.getPaymentMethod() != null ? receipt.getPaymentMethod().name() : null,
                receipt.getCurrency(),
                receipt.getCheckNumber(),
                receipt.getBankName(),
                receipt.getReferenceNumber(),
                receipt.getStatus() != null ? receipt.getStatus().name() : null,
                receipt.getNotes(),
                Timestamp.valueOf(receipt.getCreatedAt()),
                Timestamp.valueOf(receipt.getUpdatedAt()),
                receipt.getCreatedBy(),
                receipt.getUpdatedBy()
        );

        return receipt;
    }

    @Override
    public Receipt update(Receipt receipt) {
        receipt.setUpdatedAt(LocalDateTime.now());

        jdbcTemplate.update(UPDATE_RECEIPT,
                receipt.getReceiptNumber(),
                receipt.getClientId(),
                receipt.getIssueDate(),
                receipt.getTotalAmount(),
                receipt.getPaymentMethod() != null ? receipt.getPaymentMethod().name() : null,
                receipt.getCurrency(),
                receipt.getCheckNumber(),
                receipt.getBankName(),
                receipt.getReferenceNumber(),
                receipt.getStatus() != null ? receipt.getStatus().name() : null,
                receipt.getNotes(),
                Timestamp.valueOf(receipt.getUpdatedAt()),
                receipt.getUpdatedBy(),
                receipt.getId()
        );

        return receipt;
    }

    @Override
    public Optional<Receipt> findById(UUID id) {
        return jdbcTemplate.query(SELECT_BY_ID, receiptRowMapper, id).stream().findFirst();
    }

    @Override
    public Optional<Receipt> findByReceiptNumber(String receiptNumber) {
        return jdbcTemplate.query(SELECT_BY_RECEIPT_NUMBER, receiptRowMapper, receiptNumber).stream().findFirst();
    }

    @Override
    public List<Receipt> findByClientId(UUID clientId) {
        return jdbcTemplate.query(SELECT_BY_CLIENT_ID, receiptRowMapper, clientId);
    }

    @Override
    public List<Receipt> findByStatus(Receipt.ReceiptStatus status) {
        return jdbcTemplate.query(SELECT_BY_STATUS, receiptRowMapper, status.name());
    }

    @Override
    public Page<Receipt> findAll(Pageable pageable) {
        String sql = SELECT_BASE + " ORDER BY created_at DESC LIMIT ? OFFSET ?";
        List<Receipt> receipts = jdbcTemplate.query(sql, receiptRowMapper,
                pageable.getPageSize(), pageable.getOffset());

        long total = jdbcTemplate.queryForObject("SELECT COUNT(*) FROM receipts", Long.class);
        return new PageImpl<>(receipts, pageable, total);
    }

    @Override
    public Page<Receipt> findByFilters(UUID clientId, Receipt.ReceiptStatus status,
                                       LocalDate fromDate, LocalDate toDate, Pageable pageable) {
        StringBuilder sql = new StringBuilder(SELECT_BASE + " WHERE 1=1");
        List<Object> params = new ArrayList<>();

        if (clientId != null) {
            sql.append(" AND client_id = ?");
            params.add(clientId);
        }

        if (status != null) {
            sql.append(" AND status = ?::receipt_status_enum");
            params.add(status.name());
        }

        if (fromDate != null) {
            sql.append(" AND issue_date >= ?");
            params.add(fromDate);
        }

        if (toDate != null) {
            sql.append(" AND issue_date <= ?");
            params.add(toDate);
        }

        sql.append(" ORDER BY created_at DESC LIMIT ? OFFSET ?");
        params.add(pageable.getPageSize());
        params.add(pageable.getOffset());

        List<Receipt> receipts = jdbcTemplate.query(sql.toString(), receiptRowMapper, params.toArray());

        // Count query for total
        String countSql = sql.toString().replace(SELECT_BASE, "SELECT COUNT(*)").split(" ORDER BY")[0];
        long total = jdbcTemplate.queryForObject(countSql, Long.class,
                params.subList(0, params.size() - 2).toArray());

        return new PageImpl<>(receipts, pageable, total);
    }

    @Override
    public boolean existsByReceiptNumber(String receiptNumber) {
        Boolean exists = jdbcTemplate.queryForObject(EXISTS_BY_RECEIPT_NUMBER, Boolean.class, receiptNumber);
        return exists != null && exists;
    }

    @Override
    public BigDecimal getTotalByClientId(UUID clientId) {
        return jdbcTemplate.queryForObject(SUM_BY_CLIENT_ID, BigDecimal.class, clientId);
    }

    @Override
    public void deleteById(UUID id) {
        jdbcTemplate.update(DELETE_BY_ID, id);
    }

    private static class ReceiptRowMapper implements RowMapper<Receipt> {
        @Override
        public Receipt mapRow(ResultSet rs, int rowNum) throws SQLException {
            return Receipt.builder()
                    .id(UUID.fromString(rs.getString("id")))
                    .receiptNumber(rs.getString("receipt_number"))
                    .clientId(UUID.fromString(rs.getString("client_id")))
                    .issueDate(rs.getDate("issue_date") != null ?
                            rs.getDate("issue_date").toLocalDate() : null)
                    .totalAmount(rs.getBigDecimal("total_amount"))
                    .paymentMethod(rs.getString("payment_method") != null ?
                            Client.PaymentMethod.valueOf(rs.getString("payment_method")) : null)
                    .currency(rs.getString("currency"))
                    .checkNumber(rs.getString("check_number"))
                    .bankName(rs.getString("bank_name"))
                    .referenceNumber(rs.getString("reference_number"))
                    .status(rs.getString("status") != null ?
                            Receipt.ReceiptStatus.valueOf(rs.getString("status")) : null)
                    .notes(rs.getString("notes"))
                    .createdAt(rs.getTimestamp("created_at") != null ?
                            rs.getTimestamp("created_at").toLocalDateTime() : null)
                    .updatedAt(rs.getTimestamp("updated_at") != null ?
                            rs.getTimestamp("updated_at").toLocalDateTime() : null)
                    .createdBy(rs.getString("created_by") != null ?
                            UUID.fromString(rs.getString("created_by")) : null)
                    .updatedBy(rs.getString("updated_by") != null ?
                            UUID.fromString(rs.getString("updated_by")) : null)
                    .build();
        }
    }
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\data\src\main\java\com\securitybusinesssuite\data\repository\impl\ReceiptRepositoryImpl.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\data\src\main\java\com\securitybusinesssuite\data\repository\impl\SequenceRepositoryImpl.java =====
// path: data/src/main/java/com/securitybusinesssuite/data/repository/impl/SequenceRepositoryImpl.java
package com.securitybusinesssuite.data.repository.impl;

import com.securitybusinesssuite.data.entity.*;
import com.securitybusinesssuite.data.repository.SequenceRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.stereotype.Repository;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.time.LocalDateTime;
import java.util.Optional;
import java.util.UUID;

@Repository
@RequiredArgsConstructor
public class SequenceRepositoryImpl implements SequenceRepository {

    private final JdbcTemplate jdbcTemplate;

    // NCF Sequence queries
    private static final String SELECT_NCF_SEQUENCE = """
        SELECT id, ncf_type, prefix, current_number, max_number, year, is_active, created_at
        FROM ncf_sequences WHERE ncf_type = ?::ncf_type_enum AND year = ? AND is_active = true
        """;

    private static final String UPDATE_NCF_SEQUENCE = """
        UPDATE ncf_sequences SET current_number = ? WHERE id = ?
        """;

    // Client Sequence queries
    private static final String SELECT_CLIENT_SEQUENCE = """
        SELECT id, current_number, prefix, year FROM client_sequences WHERE year = ?
        """;

    private static final String INSERT_CLIENT_SEQUENCE = """
        INSERT INTO client_sequences (id, current_number, prefix, year) VALUES (?, ?, ?, ?)
        """;

    private static final String UPDATE_CLIENT_SEQUENCE = """
        UPDATE client_sequences SET current_number = ? WHERE id = ?
        """;

    // Invoice Sequence queries  
    private static final String SELECT_INVOICE_SEQUENCE = """
        SELECT id, current_number, year FROM invoice_sequences WHERE year = ?
        """;

    private static final String INSERT_INVOICE_SEQUENCE = """
        INSERT INTO invoice_sequences (id, current_number, year) VALUES (?, ?, ?)
        """;

    private static final String UPDATE_INVOICE_SEQUENCE = """
        UPDATE invoice_sequences SET current_number = ? WHERE id = ?
        """;

    // Receipt Sequence queries
    private static final String SELECT_RECEIPT_SEQUENCE = """
        SELECT id, current_number, prefix, year FROM receipt_sequences WHERE year = ?
        """;

    private static final String INSERT_RECEIPT_SEQUENCE = """
        INSERT INTO receipt_sequences (id, current_number, prefix, year) VALUES (?, ?, ?, ?)
        """;

    private static final String UPDATE_RECEIPT_SEQUENCE = """
        UPDATE receipt_sequences SET current_number = ? WHERE id = ?
        """;

    @Override
    public Optional<NCFSequence> findNCFSequenceByTypeAndYear(Invoice.NCFType type, int year) {
        return jdbcTemplate.query(SELECT_NCF_SEQUENCE, new NCFSequenceRowMapper(), type.name(), year)
                .stream().findFirst();
    }

    @Override
    public NCFSequence updateNCFSequence(NCFSequence sequence) {
        jdbcTemplate.update(UPDATE_NCF_SEQUENCE, sequence.getCurrentNumber(), sequence.getId());
        return sequence;
    }

    @Override
    public NCFSequence saveNCFSequence(NCFSequence sequence) {
        // This would typically be used for initialization, but sequences are pre-populated
        throw new UnsupportedOperationException("NCF sequences are pre-populated in migration");
    }

    @Override
    public Optional<ClientSequence> findClientSequenceByYear(int year) {
        return jdbcTemplate.query(SELECT_CLIENT_SEQUENCE, new ClientSequenceRowMapper(), year)
                .stream().findFirst();
    }

    @Override
    public ClientSequence saveClientSequence(ClientSequence sequence) {
        sequence.setId(UUID.randomUUID());
        jdbcTemplate.update(INSERT_CLIENT_SEQUENCE,
                sequence.getId(),
                sequence.getCurrentNumber(),
                sequence.getPrefix(),
                sequence.getYear()
        );
        return sequence;
    }

    @Override
    public ClientSequence updateClientSequence(ClientSequence sequence) {
        jdbcTemplate.update(UPDATE_CLIENT_SEQUENCE, sequence.getCurrentNumber(), sequence.getId());
        return sequence;
    }

    @Override
    public Optional<InvoiceSequence> findInvoiceSequenceByYear(int year) {
        return jdbcTemplate.query(SELECT_INVOICE_SEQUENCE, new InvoiceSequenceRowMapper(), year)
                .stream().findFirst();
    }

    @Override
    public InvoiceSequence saveInvoiceSequence(InvoiceSequence sequence) {
        sequence.setId(UUID.randomUUID());
        jdbcTemplate.update(INSERT_INVOICE_SEQUENCE,
                sequence.getId(),
                sequence.getCurrentNumber(),
                sequence.getYear()
        );
        return sequence;
    }

    @Override
    public InvoiceSequence updateInvoiceSequence(InvoiceSequence sequence) {
        jdbcTemplate.update(UPDATE_INVOICE_SEQUENCE, sequence.getCurrentNumber(), sequence.getId());
        return sequence;
    }

    @Override
    public Optional<ReceiptSequence> findReceiptSequenceByYear(int year) {
        return jdbcTemplate.query(SELECT_RECEIPT_SEQUENCE, new ReceiptSequenceRowMapper(), year)
                .stream().findFirst();
    }

    @Override
    public ReceiptSequence saveReceiptSequence(ReceiptSequence sequence) {
        sequence.setId(UUID.randomUUID());
        jdbcTemplate.update(INSERT_RECEIPT_SEQUENCE,
                sequence.getId(),
                sequence.getCurrentNumber(),
                sequence.getPrefix(),
                sequence.getYear()
        );
        return sequence;
    }

    @Override
    public ReceiptSequence updateReceiptSequence(ReceiptSequence sequence) {
        jdbcTemplate.update(UPDATE_RECEIPT_SEQUENCE, sequence.getCurrentNumber(), sequence.getId());
        return sequence;
    }

    // Row Mappers
    private static class NCFSequenceRowMapper implements RowMapper<NCFSequence> {
        @Override
        public NCFSequence mapRow(ResultSet rs, int rowNum) throws SQLException {
            return NCFSequence.builder()
                    .id(UUID.fromString(rs.getString("id")))
                    .ncfType(Invoice.NCFType.valueOf(rs.getString("ncf_type")))
                    .prefix(rs.getString("prefix"))
                    .currentNumber(rs.getLong("current_number"))
                    .maxNumber(rs.getLong("max_number"))
                    .year(rs.getInt("year"))
                    .isActive(rs.getBoolean("is_active"))
                    .createdAt(rs.getTimestamp("created_at").toLocalDateTime())
                    .build();
        }
    }

    private static class ClientSequenceRowMapper implements RowMapper<ClientSequence> {
        @Override
        public ClientSequence mapRow(ResultSet rs, int rowNum) throws SQLException {
            return ClientSequence.builder()
                    .id(UUID.fromString(rs.getString("id")))
                    .currentNumber(rs.getInt("current_number"))
                    .prefix(rs.getString("prefix"))
                    .year(rs.getInt("year"))
                    .build();
        }
    }

    private static class InvoiceSequenceRowMapper implements RowMapper<InvoiceSequence> {
        @Override
        public InvoiceSequence mapRow(ResultSet rs, int rowNum) throws SQLException {
            return InvoiceSequence.builder()
                    .id(UUID.fromString(rs.getString("id")))
                    .currentNumber(rs.getInt("current_number"))
                    .year(rs.getInt("year"))
                    .build();
        }
    }

    private static class ReceiptSequenceRowMapper implements RowMapper<ReceiptSequence> {
        @Override
        public ReceiptSequence mapRow(ResultSet rs, int rowNum) throws SQLException {
            return ReceiptSequence.builder()
                    .id(UUID.fromString(rs.getString("id")))
                    .currentNumber(rs.getInt("current_number"))
                    .prefix(rs.getString("prefix"))
                    .year(rs.getInt("year"))
                    .build();
        }
    }
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\data\src\main\java\com\securitybusinesssuite\data\repository\impl\SequenceRepositoryImpl.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\data\src\main\java\com\securitybusinesssuite\data\repository\impl\UserRepositoryImpl.java =====
// path: data/src/main/java/com/securitybusinesssuite/data/repository/impl/UserRepositoryImpl.java
package com.securitybusinesssuite.data.repository.impl;

import com.securitybusinesssuite.data.entity.User;
import com.securitybusinesssuite.data.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.stereotype.Repository;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.time.LocalDateTime;
import java.util.Optional;
import java.util.UUID;

@Repository
@RequiredArgsConstructor
public class UserRepositoryImpl implements UserRepository {

    private final JdbcTemplate jdbcTemplate;

    private static final String INSERT_USER = """
        INSERT INTO users (id, email, password_hash, first_name, last_name, 
                          email_verified, provider, provider_id, email_verification_token,
                          email_verification_token_expiry, created_at, updated_at)
        VALUES (?, ?, ?, ?, ?, ?, ?::auth_provider, ?, ?, ?, ?, ?)
        """;

    private static final String UPDATE_USER = """
        UPDATE users SET email = ?, password_hash = ?, first_name = ?, last_name = ?,
                        email_verified = ?, provider = ?::auth_provider, provider_id = ?,
                        email_verification_token = ?, email_verification_token_expiry = ?,
                        updated_at = ?
        WHERE id = ?
        """;

    private static final String SELECT_BY_ID = """
        SELECT * FROM users WHERE id = ?
        """;

    private static final String SELECT_BY_EMAIL = """
        SELECT * FROM users WHERE LOWER(email) = LOWER(?)
        """;

    private static final String SELECT_BY_TOKEN = """
        SELECT * FROM users WHERE email_verification_token = ?
        """;

    private static final String SELECT_BY_PROVIDER = """
        SELECT * FROM users WHERE provider = ?::auth_provider AND provider_id = ?
        """;

    private static final String EXISTS_BY_EMAIL = """
        SELECT EXISTS(SELECT 1 FROM users WHERE LOWER(email) = LOWER(?))
        """;

    private static final String DELETE_BY_ID = """
        DELETE FROM users WHERE id = ?
        """;

    private final RowMapper<User> userRowMapper = new UserRowMapper();

    @Override
    public User save(User user) {
        user.setId(UUID.randomUUID());
        user.setCreatedAt(LocalDateTime.now());
        user.setUpdatedAt(LocalDateTime.now());

        jdbcTemplate.update(INSERT_USER,
                user.getId(),
                user.getEmail(),
                user.getPasswordHash(),
                user.getFirstName(),
                user.getLastName(),
                user.isEmailVerified(),
                user.getProvider().name(),
                user.getProviderId(),
                user.getEmailVerificationToken(),
                user.getEmailVerificationTokenExpiry() != null ?
                        Timestamp.valueOf(user.getEmailVerificationTokenExpiry()) : null,
                Timestamp.valueOf(user.getCreatedAt()),
                Timestamp.valueOf(user.getUpdatedAt())
        );

        return user;
    }

    @Override
    public User update(User user) {
        user.setUpdatedAt(LocalDateTime.now());

        jdbcTemplate.update(UPDATE_USER,
                user.getEmail(),
                user.getPasswordHash(),
                user.getFirstName(),
                user.getLastName(),
                user.isEmailVerified(),
                user.getProvider().name(),
                user.getProviderId(),
                user.getEmailVerificationToken(),
                user.getEmailVerificationTokenExpiry() != null ?
                        Timestamp.valueOf(user.getEmailVerificationTokenExpiry()) : null,
                Timestamp.valueOf(user.getUpdatedAt()),
                user.getId()
        );

        return user;
    }

    @Override
    public Optional<User> findById(UUID id) {
        return jdbcTemplate.query(SELECT_BY_ID, userRowMapper, id)
                .stream().findFirst();
    }

    @Override
    public Optional<User> findByEmail(String email) {
        return jdbcTemplate.query(SELECT_BY_EMAIL, userRowMapper, email)
                .stream().findFirst();
    }

    @Override
    public Optional<User> findByEmailVerificationToken(String token) {
        return jdbcTemplate.query(SELECT_BY_TOKEN, userRowMapper, token)
                .stream().findFirst();
    }

    @Override
    public Optional<User> findByProviderAndProviderId(User.AuthProvider provider, String providerId) {
        return jdbcTemplate.query(SELECT_BY_PROVIDER, userRowMapper, provider.name(), providerId)
                .stream().findFirst();
    }

    @Override
    public boolean existsByEmail(String email) {
        Boolean exists = jdbcTemplate.queryForObject(EXISTS_BY_EMAIL, Boolean.class, email);
        return exists != null && exists;
    }

    @Override
    public void deleteById(UUID id) {
        jdbcTemplate.update(DELETE_BY_ID, id);
    }

    private static class UserRowMapper implements RowMapper<User> {
        @Override
        public User mapRow(ResultSet rs, int rowNum) throws SQLException {
            Timestamp tokenExpiry = rs.getTimestamp("email_verification_token_expiry");

            return User.builder()
                    .id(UUID.fromString(rs.getString("id")))
                    .email(rs.getString("email"))
                    .passwordHash(rs.getString("password_hash"))
                    .firstName(rs.getString("first_name"))
                    .lastName(rs.getString("last_name"))
                    .emailVerified(rs.getBoolean("email_verified"))
                    .provider(User.AuthProvider.valueOf(rs.getString("provider")))
                    .providerId(rs.getString("provider_id"))
                    .emailVerificationToken(rs.getString("email_verification_token"))
                    .emailVerificationTokenExpiry(tokenExpiry != null ? tokenExpiry.toLocalDateTime() : null)
                    .createdAt(rs.getTimestamp("created_at").toLocalDateTime())
                    .updatedAt(rs.getTimestamp("updated_at").toLocalDateTime())
                    .build();
        }
    }
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\data\src\main\java\com\securitybusinesssuite\data\repository\impl\UserRepositoryImpl.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\data\src\main\java\com\securitybusinesssuite\data\repository\InvoiceItemRepository.java =====
// path: data/src/main/java/com/securitybusinesssuite/data/repository/InvoiceItemRepository.java
package com.securitybusinesssuite.data.repository;

import com.securitybusinesssuite.data.entity.InvoiceItem;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

public interface InvoiceItemRepository {
    InvoiceItem save(InvoiceItem item);
    InvoiceItem update(InvoiceItem item);
    Optional<InvoiceItem> findById(UUID id);
    List<InvoiceItem> findByInvoiceId(UUID invoiceId);
    void deleteById(UUID id);
    void deleteByInvoiceId(UUID invoiceId);
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\data\src\main\java\com\securitybusinesssuite\data\repository\InvoiceItemRepository.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\data\src\main\java\com\securitybusinesssuite\data\repository\InvoiceRepository.java =====
// path: data/src/main/java/com/securitybusinesssuite/data/repository/InvoiceRepository.java
package com.securitybusinesssuite.data.repository;

import com.securitybusinesssuite.data.entity.Invoice;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

public interface InvoiceRepository {
    Invoice save(Invoice invoice);
    Invoice update(Invoice invoice);
    Optional<Invoice> findById(UUID id);
    Optional<Invoice> findByInvoiceNumber(String invoiceNumber);
    Optional<Invoice> findByNcf(String ncf);
    List<Invoice> findByClientId(UUID clientId);
    List<Invoice> findByStatus(Invoice.InvoiceStatus status);
    List<Invoice> findByStatusAndDueDateBefore(Invoice.InvoiceStatus status, LocalDate date);
    List<Invoice> findOverdueInvoices();
    Page<Invoice> findAll(Pageable pageable);
    Page<Invoice> findByFilters(UUID clientId, Invoice.InvoiceStatus status,
                                LocalDate fromDate, LocalDate toDate,
                                BigDecimal minAmount, BigDecimal maxAmount, Pageable pageable);
    boolean existsByInvoiceNumber(String invoiceNumber);
    boolean existsByNcf(String ncf);
    BigDecimal getTotalByClientAndStatus(UUID clientId, Invoice.InvoiceStatus status);
    long countByStatus(Invoice.InvoiceStatus status);
    void deleteById(UUID id);
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\data\src\main\java\com\securitybusinesssuite\data\repository\InvoiceRepository.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\data\src\main\java\com\securitybusinesssuite\data\repository\ReceiptAllocationRepository.java =====
// path: data/src/main/java/com/securitybusinesssuite/data/repository/ReceiptAllocationRepository.java
package com.securitybusinesssuite.data.repository;

import com.securitybusinesssuite.data.entity.ReceiptAllocation;
import java.math.BigDecimal;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

public interface ReceiptAllocationRepository {
    ReceiptAllocation save(ReceiptAllocation allocation);
    Optional<ReceiptAllocation> findById(UUID id);
    List<ReceiptAllocation> findByReceiptId(UUID receiptId);
    List<ReceiptAllocation> findByInvoiceId(UUID invoiceId);
    BigDecimal getTotalAllocatedByReceiptId(UUID receiptId);
    BigDecimal getTotalAllocatedByInvoiceId(UUID invoiceId);
    void deleteById(UUID id);
    void deleteByReceiptId(UUID receiptId);
}

===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\data\src\main\java\com\securitybusinesssuite\data\repository\ReceiptAllocationRepository.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\data\src\main\java\com\securitybusinesssuite\data\repository\ReceiptRepository.java =====
// path: data/src/main/java/com/securitybusinesssuite/data/repository/ReceiptRepository.java
package com.securitybusinesssuite.data.repository;

import com.securitybusinesssuite.data.entity.Receipt;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

public interface ReceiptRepository {
    Receipt save(Receipt receipt);
    Receipt update(Receipt receipt);
    Optional<Receipt> findById(UUID id);
    Optional<Receipt> findByReceiptNumber(String receiptNumber);
    List<Receipt> findByClientId(UUID clientId);
    List<Receipt> findByStatus(Receipt.ReceiptStatus status);
    Page<Receipt> findAll(Pageable pageable);
    Page<Receipt> findByFilters(UUID clientId, Receipt.ReceiptStatus status,
                                LocalDate fromDate, LocalDate toDate, Pageable pageable);
    boolean existsByReceiptNumber(String receiptNumber);
    BigDecimal getTotalByClientId(UUID clientId);
    void deleteById(UUID id);
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\data\src\main\java\com\securitybusinesssuite\data\repository\ReceiptRepository.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\data\src\main\java\com\securitybusinesssuite\data\repository\SequenceRepository.java =====
// path: data/src/main/java/com/securitybusinesssuite/data/repository/SequenceRepository.java
package com.securitybusinesssuite.data.repository;

import com.securitybusinesssuite.data.entity.*;
import java.util.Optional;

public interface SequenceRepository {
    // NCF Sequences
    Optional<NCFSequence> findNCFSequenceByTypeAndYear(Invoice.NCFType type, int year);
    NCFSequence saveNCFSequence(NCFSequence sequence);
    NCFSequence updateNCFSequence(NCFSequence sequence);

    // Client Sequences
    Optional<ClientSequence> findClientSequenceByYear(int year);
    ClientSequence saveClientSequence(ClientSequence sequence);
    ClientSequence updateClientSequence(ClientSequence sequence);

    // Invoice Sequences
    Optional<InvoiceSequence> findInvoiceSequenceByYear(int year);
    InvoiceSequence saveInvoiceSequence(InvoiceSequence sequence);
    InvoiceSequence updateInvoiceSequence(InvoiceSequence sequence);

    // Receipt Sequences
    Optional<ReceiptSequence> findReceiptSequenceByYear(int year);
    ReceiptSequence saveReceiptSequence(ReceiptSequence sequence);
    ReceiptSequence updateReceiptSequence(ReceiptSequence sequence);
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\data\src\main\java\com\securitybusinesssuite\data\repository\SequenceRepository.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\data\src\main\java\com\securitybusinesssuite\data\repository\UserRepository.java =====
// path: data/src/main/java/com/securitybusinesssuite/data/repository/UserRepository.java
package com.securitybusinesssuite.data.repository;

import com.securitybusinesssuite.data.entity.User;
import java.util.Optional;
import java.util.UUID;

public interface UserRepository {
    User save(User user);
    User update(User user);
    Optional<User> findById(UUID id);
    Optional<User> findByEmail(String email);
    Optional<User> findByEmailVerificationToken(String token);
    Optional<User> findByProviderAndProviderId(User.AuthProvider provider, String providerId);
    boolean existsByEmail(String email);
    void deleteById(UUID id);
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\data\src\main\java\com\securitybusinesssuite\data\repository\UserRepository.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\data\src\main\resources\db\migration\V1__create_users_table.sql =====
-- path: data/src/main/resources/db/migration/V1__create_users_table.sql
CREATE TYPE auth_provider AS ENUM ('LOCAL', 'GOOGLE');

CREATE TABLE users (
                       id UUID PRIMARY KEY,
                       email VARCHAR(255) NOT NULL UNIQUE,
                       password_hash VARCHAR(255),
                       first_name VARCHAR(100),
                       last_name VARCHAR(100),
                       email_verified BOOLEAN DEFAULT FALSE,
                       provider auth_provider NOT NULL DEFAULT 'LOCAL',
                       provider_id VARCHAR(255),
                       email_verification_token VARCHAR(255),
                       email_verification_token_expiry TIMESTAMP,
                       created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
                       updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- Create indexes for performance
CREATE INDEX idx_users_email ON users(LOWER(email));
CREATE INDEX idx_users_provider_id ON users(provider, provider_id) WHERE provider_id IS NOT NULL;
CREATE INDEX idx_users_verification_token ON users(email_verification_token) WHERE email_verification_token IS NOT NULL;
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\data\src\main\resources\db\migration\V1__create_users_table.sql =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\data\src\main\resources\db\migration\V2__add_oauth_indexes.sql =====
-- path: data/src/main/resources/db/migration/V2__add_oauth_indexes.sql
-- Additional indexes for OAuth optimization
CREATE INDEX idx_users_email_verified ON users(email_verified);
CREATE INDEX idx_users_created_at ON users(created_at DESC);

-- Add constraint for provider_id uniqueness per provider
ALTER TABLE users ADD CONSTRAINT unique_provider_id
    UNIQUE NULLS NOT DISTINCT (provider, provider_id);
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\data\src\main\resources\db\migration\V2__add_oauth_indexes.sql =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\data\src\main\resources\db\migration\V3__client_invoice_receipt_tables.sql =====
-- =====================================================
-- CLEAN SQL SCHEMA - DOMINICAN REPUBLIC BUSINESS
-- Security Business Suite - ASEPRE
-- No triggers, no complex constraints - Pure table definitions
-- =====================================================

-- Enums for Dominican Republic specific types
CREATE TYPE client_type_enum AS ENUM ('PERSONA_FISICA', 'SRL', 'CONSUMIDOR_FINAL');
CREATE TYPE business_sector_enum AS ENUM ('DEALER_AUTOS', 'RESIDENCIAL', 'COOPERATIVA', 'GOBIERNO', 'INDIVIDUAL');
CREATE TYPE security_service_enum AS ENUM ('PUESTO_FIJO', 'PATRULLAJE', 'ESCOLTA');
CREATE TYPE payment_method_enum AS ENUM ('EFECTIVO', 'CHEQUE', 'TRANSFERENCIA_BANCARIA');
CREATE TYPE client_status_enum AS ENUM ('ACTIVE', 'INACTIVE', 'SUSPENDED');
CREATE TYPE invoice_type_enum AS ENUM ('CREDITO', 'CONTADO');
CREATE TYPE invoice_status_enum AS ENUM ('PENDING', 'PAID', 'OVERDUE', 'CANCELLED');
CREATE TYPE receipt_status_enum AS ENUM ('ACTIVE', 'CANCELLED', 'VOIDED');
CREATE TYPE ncf_type_enum AS ENUM ('B01', 'B02');

-- =====================================================
-- CLIENTS TABLE
-- =====================================================
CREATE TABLE clients (
                         id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

    -- Client Identification
                         client_code TEXT UNIQUE NOT NULL,
                         rnc TEXT,
                         client_type client_type_enum NOT NULL,

    -- Business Information
                         business_name TEXT NOT NULL,
                         contact_person TEXT,
                         business_sector business_sector_enum,

    -- Contact Information
                         phone TEXT,
                         email TEXT,

    -- Dominican Address Format
                         street_name TEXT,
                         street_number TEXT,
                         sector TEXT,
                         provincia TEXT,

    -- Services and Contract Info
                         services security_service_enum[],
                         has_contract BOOLEAN DEFAULT FALSE,
                         contract_start_date DATE,
                         contract_end_date DATE,
                         auto_renewal BOOLEAN DEFAULT TRUE,

    -- Payment Information
                         payment_method payment_method_enum,
                         hourly_rate NUMERIC(10,2),

    -- Tax Information
                         requires_ncf BOOLEAN NOT NULL DEFAULT TRUE,
                         requires_rnc BOOLEAN NOT NULL DEFAULT TRUE,
                         applies_itbis BOOLEAN NOT NULL DEFAULT TRUE,

    -- Status and Audit
                         status client_status_enum NOT NULL DEFAULT 'ACTIVE',
                         notes TEXT,
                         created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
                         updated_at TIMESTAMPTZ,
                         created_by UUID NOT NULL REFERENCES users(id),
                         updated_by UUID REFERENCES users(id)
);

-- =====================================================
-- NCF SEQUENCE MANAGEMENT
-- =====================================================
CREATE TABLE ncf_sequences (
                               id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
                               ncf_type ncf_type_enum UNIQUE NOT NULL,
                               prefix TEXT NOT NULL,
                               current_number BIGINT NOT NULL DEFAULT 0,
                               max_number BIGINT NOT NULL DEFAULT 99999999,
                               year INTEGER NOT NULL DEFAULT EXTRACT(YEAR FROM CURRENT_DATE),
                               is_active BOOLEAN NOT NULL DEFAULT TRUE,
                               created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- =====================================================
-- INVOICES TABLE
-- =====================================================
CREATE TABLE invoices (
                          id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

    -- Invoice Identification
                          invoice_number TEXT UNIQUE NOT NULL,
                          ncf TEXT UNIQUE,
                          ncf_type ncf_type_enum,

    -- Client Reference
                          client_id UUID NOT NULL REFERENCES clients(id),

    -- Invoice Dates
                          issue_date DATE NOT NULL,
                          due_date DATE NOT NULL,

    -- Invoice Type
                          invoice_type invoice_type_enum NOT NULL DEFAULT 'CREDITO',

    -- Amounts (calculated by backend services)
                          subtotal NUMERIC(12,2) NOT NULL,
                          itbis_amount NUMERIC(12,2) NOT NULL,
                          discount_amount NUMERIC(12,2) NOT NULL DEFAULT 0.00,
                          total_amount NUMERIC(12,2) NOT NULL,
                          net_amount NUMERIC(12,2) NOT NULL,

    -- Payment tracking (calculated by backend services)
                          paid_amount NUMERIC(12,2) NOT NULL DEFAULT 0.00,
                          balance_due NUMERIC(12,2) NOT NULL DEFAULT 0.00,

    -- Status and Notes
                          status invoice_status_enum NOT NULL DEFAULT 'PENDING',
                          notes TEXT,

    -- Future e-CF compliance fields
                          dgii_track_id TEXT,
                          dgii_status TEXT,
                          ecf_payload JSONB,
                          qr_hash TEXT,

    -- Audit
                          created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
                          updated_at TIMESTAMPTZ,
                          created_by UUID NOT NULL REFERENCES users(id),
                          updated_by UUID REFERENCES users(id)
);

-- =====================================================
-- INVOICE ITEMS TABLE
-- =====================================================
CREATE TABLE invoice_items (
                               id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
                               invoice_id UUID NOT NULL REFERENCES invoices(id) ON DELETE CASCADE,

    -- Service Information
                               service_code TEXT NOT NULL DEFAULT 'SF-0001',
                               description TEXT NOT NULL DEFAULT 'SERVICIO SEGURIDAD PRIVADA',
                               service_type security_service_enum,

    -- Pricing
                               quantity NUMERIC(8,2) NOT NULL DEFAULT 1.0,
                               unit_price NUMERIC(12,2) NOT NULL,

    -- Tax Information
                               itbis_rate NUMERIC(5,4) NOT NULL DEFAULT 0.1800,
                               itbis_amount NUMERIC(12,2) NOT NULL,

    -- Discounts
                               discount_percentage NUMERIC(5,2) NOT NULL DEFAULT 0.00,
                               discount_amount NUMERIC(12,2) NOT NULL DEFAULT 0.00,

    -- Totals (calculated by backend services)
                               line_subtotal NUMERIC(12,2) NOT NULL,
                               line_total NUMERIC(12,2) NOT NULL,

    -- Audit
                               created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
                               created_by UUID NOT NULL REFERENCES users(id)
);

-- =====================================================
-- RECEIPTS TABLE (Payment Records)
-- =====================================================
CREATE TABLE receipts (
                          id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

    -- Receipt Identification
                          receipt_number TEXT UNIQUE NOT NULL,

    -- Client and Date
                          client_id UUID NOT NULL REFERENCES clients(id),
                          issue_date DATE NOT NULL,

    -- Payment Information
                          total_amount NUMERIC(12,2) NOT NULL,
                          payment_method payment_method_enum NOT NULL,
                          currency CHAR(3) NOT NULL DEFAULT 'DOP',

    -- Payment Method Details
                          check_number TEXT,
                          bank_name TEXT,
                          reference_number TEXT,

    -- Status and Notes
                          status receipt_status_enum NOT NULL DEFAULT 'ACTIVE',
                          notes TEXT,

    -- Audit
                          created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
                          updated_at TIMESTAMPTZ,
                          created_by UUID NOT NULL REFERENCES users(id),
                          updated_by UUID REFERENCES users(id)
);

-- =====================================================
-- RECEIPT ALLOCATIONS (Payment Applications)
-- =====================================================
CREATE TABLE receipt_allocations (
                                     id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
                                     receipt_id UUID NOT NULL REFERENCES receipts(id) ON DELETE CASCADE,
                                     invoice_id UUID NOT NULL REFERENCES invoices(id),
                                     allocated_amount NUMERIC(12,2) NOT NULL,

    -- Audit
                                     created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
                                     created_by UUID NOT NULL REFERENCES users(id)
);

-- =====================================================
-- SEQUENCE TABLES FOR AUTO-NUMBERING
-- =====================================================
CREATE TABLE client_sequences (
                                  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
                                  current_number INTEGER NOT NULL DEFAULT 0,
                                  prefix TEXT NOT NULL DEFAULT 'I',
                                  year INTEGER NOT NULL DEFAULT EXTRACT(YEAR FROM CURRENT_DATE)
);

CREATE TABLE invoice_sequences (
                                   id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
                                   current_number INTEGER NOT NULL DEFAULT 0,
                                   year INTEGER NOT NULL DEFAULT EXTRACT(YEAR FROM CURRENT_DATE)
);

CREATE TABLE receipt_sequences (
                                   id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
                                   current_number INTEGER NOT NULL DEFAULT 0,
                                   prefix TEXT NOT NULL DEFAULT 'REC',
                                   year INTEGER NOT NULL DEFAULT EXTRACT(YEAR FROM CURRENT_DATE)
);

-- =====================================================
-- INDEXES FOR PERFORMANCE
-- =====================================================

-- Client indexes
CREATE INDEX idx_clients_rnc ON clients(rnc) WHERE rnc IS NOT NULL;
CREATE INDEX idx_clients_client_code ON clients(client_code);
CREATE INDEX idx_clients_business_name ON clients(LOWER(business_name));
CREATE INDEX idx_clients_status ON clients(status);
CREATE INDEX idx_clients_client_type ON clients(client_type);

-- Invoice indexes
CREATE INDEX idx_invoices_client_id ON invoices(client_id);
CREATE INDEX idx_invoices_ncf ON invoices(ncf) WHERE ncf IS NOT NULL;
CREATE INDEX idx_invoices_invoice_number ON invoices(invoice_number);
CREATE INDEX idx_invoices_issue_date ON invoices(issue_date);
CREATE INDEX idx_invoices_due_date ON invoices(due_date);
CREATE INDEX idx_invoices_status ON invoices(status);
CREATE INDEX idx_invoices_balance_due ON invoices(balance_due) WHERE balance_due > 0;

-- Receipt indexes
CREATE INDEX idx_receipts_client_id ON receipts(client_id);
CREATE INDEX idx_receipts_receipt_number ON receipts(receipt_number);
CREATE INDEX idx_receipts_issue_date ON receipts(issue_date);
CREATE INDEX idx_receipts_status ON receipts(status);

-- Allocation indexes
CREATE INDEX idx_receipt_allocations_receipt_id ON receipt_allocations(receipt_id);
CREATE INDEX idx_receipt_allocations_invoice_id ON receipt_allocations(invoice_id);

-- =====================================================
-- BASIC CONSTRAINTS (Data Integrity Only)
-- =====================================================

-- Basic data integrity constraints only
ALTER TABLE invoices ADD CONSTRAINT chk_positive_amounts
    CHECK (subtotal >= 0 AND itbis_amount >= 0 AND total_amount >= 0);

ALTER TABLE invoice_items ADD CONSTRAINT chk_positive_line_amounts
    CHECK (quantity > 0 AND unit_price >= 0 AND line_total >= 0);

ALTER TABLE receipts ADD CONSTRAINT chk_positive_receipt_amount
    CHECK (total_amount > 0);

ALTER TABLE receipt_allocations ADD CONSTRAINT chk_positive_allocation
    CHECK (allocated_amount > 0);

-- =====================================================
-- INITIAL DATA SETUP
-- =====================================================

-- Initialize NCF sequences
INSERT INTO ncf_sequences (ncf_type, prefix, current_number, year) VALUES
                                                                       ('B01', 'B01', 0, EXTRACT(YEAR FROM CURRENT_DATE)),
                                                                       ('B02', 'B02', 0, EXTRACT(YEAR FROM CURRENT_DATE));

-- Initialize other sequences
INSERT INTO client_sequences (current_number, prefix, year) VALUES
    (0, 'I', EXTRACT(YEAR FROM CURRENT_DATE));

INSERT INTO invoice_sequences (current_number, year) VALUES
    (0, EXTRACT(YEAR FROM CURRENT_DATE));

INSERT INTO receipt_sequences (current_number, prefix, year) VALUES
    (0, 'REC', EXTRACT(YEAR FROM CURRENT_DATE));

-- =====================================================
-- COMMENTS FOR DOCUMENTATION
-- =====================================================

COMMENT ON TABLE clients IS 'Client master data with Dominican Republic specific fields';
COMMENT ON COLUMN clients.rnc IS 'Registro Nacional del Contribuyente - required for business clients';
COMMENT ON COLUMN clients.requires_ncf IS 'Whether this client requires NCF on invoices';

COMMENT ON TABLE invoices IS 'Invoice header with NCF compliance for Dominican Republic';
COMMENT ON COLUMN invoices.ncf IS 'Número de Comprobante Fiscal - required for business clients';
COMMENT ON COLUMN invoices.balance_due IS 'Calculated field: total_amount - paid_amount';

COMMENT ON TABLE receipts IS 'Payment receipts - legal documents in Dominican Republic';
COMMENT ON TABLE receipt_allocations IS 'Applications of payments to specific invoices';

COMMENT ON TABLE ncf_sequences IS 'Manages NCF number sequences for DGII compliance';
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\data\src\main\resources\db\migration\V3__client_invoice_receipt_tables.sql =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\gradle\wrapper\gradle-wrapper.properties =====
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.14.3-bin.zip
networkTimeout=10000
validateDistributionUrl=true
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists
# path: gradle.properties
org.gradle.jvmargs=-Xmx2048m
org.gradle.parallel=true
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\gradle\wrapper\gradle-wrapper.properties =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\gradlew =====
#!/bin/sh

#
# Copyright © 2015-2021 the original authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# SPDX-License-Identifier: Apache-2.0
#

##############################################################################
#
#   Gradle start up script for POSIX generated by Gradle.
#
#   Important for running:
#
#   (1) You need a POSIX-compliant shell to run this script. If your /bin/sh is
#       noncompliant, but you have some other compliant shell such as ksh or
#       bash, then to run this script, type that shell name before the whole
#       command line, like:
#
#           ksh Gradle
#
#       Busybox and similar reduced shells will NOT work, because this script
#       requires all of these POSIX shell features:
#         * functions;
#         * expansions «$var», «${var}», «${var:-default}», «${var+SET}»,
#           «${var#prefix}», «${var%suffix}», and «$( cmd )»;
#         * compound commands having a testable exit status, especially «case»;
#         * various built-in commands including «command», «set», and «ulimit».
#
#   Important for patching:
#
#   (2) This script targets any POSIX shell, so it avoids extensions provided
#       by Bash, Ksh, etc; in particular arrays are avoided.
#
#       The "traditional" practice of packing multiple parameters into a
#       space-separated string is a well documented source of bugs and security
#       problems, so this is (mostly) avoided, by progressively accumulating
#       options in "$@", and eventually passing that to Java.
#
#       Where the inherited environment variables (DEFAULT_JVM_OPTS, JAVA_OPTS,
#       and GRADLE_OPTS) rely on word-splitting, this is performed explicitly;
#       see the in-line comments for details.
#
#       There are tweaks for specific operating systems such as AIX, CygWin,
#       Darwin, MinGW, and NonStop.
#
#   (3) This script is generated from the Groovy template
#       https://github.com/gradle/gradle/blob/HEAD/platforms/jvm/plugins-application/src/main/resources/org/gradle/api/internal/plugins/unixStartScript.txt
#       within the Gradle project.
#
#       You can find Gradle at https://github.com/gradle/gradle/.
#
##############################################################################

# Attempt to set APP_HOME

# Resolve links: $0 may be a link
app_path=$0

# Need this for daisy-chained symlinks.
while
    APP_HOME=${app_path%"${app_path##*/}"}  # leaves a trailing /; empty if no leading path
    [ -h "$app_path" ]
do
    ls=$( ls -ld "$app_path" )
    link=${ls#*' -> '}
    case $link in             #(
      /*)   app_path=$link ;; #(
      *)    app_path=$APP_HOME$link ;;
    esac
done

# This is normally unused
# shellcheck disable=SC2034
APP_BASE_NAME=${0##*/}
# Discard cd standard output in case $CDPATH is set (https://github.com/gradle/gradle/issues/25036)
APP_HOME=$( cd -P "${APP_HOME:-./}" > /dev/null && printf '%s\n' "$PWD" ) || exit

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD=maximum

warn () {
    echo "$*"
} >&2

die () {
    echo
    echo "$*"
    echo
    exit 1
} >&2

# OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
nonstop=false
case "$( uname )" in                #(
  CYGWIN* )         cygwin=true  ;; #(
  Darwin* )         darwin=true  ;; #(
  MSYS* | MINGW* )  msys=true    ;; #(
  NONSTOP* )        nonstop=true ;;
esac

CLASSPATH="\\\"\\\""


# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD=$JAVA_HOME/jre/sh/java
    else
        JAVACMD=$JAVA_HOME/bin/java
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD=java
    if ! command -v java >/dev/null 2>&1
    then
        die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
fi

# Increase the maximum file descriptors if we can.
if ! "$cygwin" && ! "$darwin" && ! "$nonstop" ; then
    case $MAX_FD in #(
      max*)
        # In POSIX sh, ulimit -H is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        MAX_FD=$( ulimit -H -n ) ||
            warn "Could not query maximum file descriptor limit"
    esac
    case $MAX_FD in  #(
      '' | soft) :;; #(
      *)
        # In POSIX sh, ulimit -n is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        ulimit -n "$MAX_FD" ||
            warn "Could not set maximum file descriptor limit to $MAX_FD"
    esac
fi

# Collect all arguments for the java command, stacking in reverse order:
#   * args from the command line
#   * the main class name
#   * -classpath
#   * -D...appname settings
#   * --module-path (only if needed)
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, and GRADLE_OPTS environment variables.

# For Cygwin or MSYS, switch paths to Windows format before running java
if "$cygwin" || "$msys" ; then
    APP_HOME=$( cygpath --path --mixed "$APP_HOME" )
    CLASSPATH=$( cygpath --path --mixed "$CLASSPATH" )

    JAVACMD=$( cygpath --unix "$JAVACMD" )

    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    for arg do
        if
            case $arg in                                #(
              -*)   false ;;                            # don't mess with options #(
              /?*)  t=${arg#/} t=/${t%%/*}              # looks like a POSIX filepath
                    [ -e "$t" ] ;;                      #(
              *)    false ;;
            esac
        then
            arg=$( cygpath --path --ignore --mixed "$arg" )
        fi
        # Roll the args list around exactly as many times as the number of
        # args, so each arg winds up back in the position where it started, but
        # possibly modified.
        #
        # NB: a `for` loop captures its iteration list before it begins, so
        # changing the positional parameters here affects neither the number of
        # iterations, nor the values presented in `arg`.
        shift                   # remove old arg
        set -- "$@" "$arg"      # push replacement arg
    done
fi


# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'

# Collect all arguments for the java command:
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, and optsEnvironmentVar are not allowed to contain shell fragments,
#     and any embedded shellness will be escaped.
#   * For example: A user cannot expect ${Hostname} to be expanded, as it is an environment variable and will be
#     treated as '${Hostname}' itself on the command line.

set -- \
        "-Dorg.gradle.appname=$APP_BASE_NAME" \
        -classpath "$CLASSPATH" \
        -jar "$APP_HOME/gradle/wrapper/gradle-wrapper.jar" \
        "$@"

# Stop when "xargs" is not available.
if ! command -v xargs >/dev/null 2>&1
then
    die "xargs is not available"
fi

# Use "xargs" to parse quoted args.
#
# With -n1 it outputs one arg per line, with the quotes and backslashes removed.
#
# In Bash we could simply go:
#
#   readarray ARGS < <( xargs -n1 <<<"$var" ) &&
#   set -- "${ARGS[@]}" "$@"
#
# but POSIX shell has neither arrays nor command substitution, so instead we
# post-process each arg (as a line of input to sed) to backslash-escape any
# character that might be a shell metacharacter, then use eval to reverse
# that process (while maintaining the separation between arguments), and wrap
# the whole thing up as a single "set" statement.
#
# This will of course break if any of these variables contains a newline or
# an unmatched quote.
#

eval "set -- $(
        printf '%s\n' "$DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS" |
        xargs -n1 |
        sed ' s~[^-[:alnum:]+,./:=@_]~\\&~g; ' |
        tr '\n' ' '
    )" '"$@"'

exec "$JAVACMD" "$@"

===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\gradlew =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\gradlew.bat =====
@rem
@rem Copyright 2015 the original author or authors.
@rem
@rem Licensed under the Apache License, Version 2.0 (the "License");
@rem you may not use this file except in compliance with the License.
@rem You may obtain a copy of the License at
@rem
@rem      https://www.apache.org/licenses/LICENSE-2.0
@rem
@rem Unless required by applicable law or agreed to in writing, software
@rem distributed under the License is distributed on an "AS IS" BASIS,
@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@rem See the License for the specific language governing permissions and
@rem limitations under the License.
@rem
@rem SPDX-License-Identifier: Apache-2.0
@rem

@if "%DEBUG%"=="" @echo off
@rem ##########################################################################
@rem
@rem  Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

set DIRNAME=%~dp0
if "%DIRNAME%"=="" set DIRNAME=.
@rem This is normally unused
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Resolve any "." and ".." in APP_HOME to make it shorter.
for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if %ERRORLEVEL% equ 0 goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH. 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME% 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:execute
@rem Setup the command line

set CLASSPATH=


@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" -jar "%APP_HOME%\gradle\wrapper\gradle-wrapper.jar" %*

:end
@rem End local scope for the variables with windows NT shell
if %ERRORLEVEL% equ 0 goto mainEnd

:fail
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
set EXIT_CODE=%ERRORLEVEL%
if %EXIT_CODE% equ 0 set EXIT_CODE=1
if not ""=="%GRADLE_EXIT_CONSOLE%" exit %EXIT_CODE%
exit /b %EXIT_CODE%

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega

===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\gradlew.bat =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\HELP.md =====
# Getting Started

### Reference Documentation

For further reference, please consider the following sections:

* [Official Gradle documentation](https://docs.gradle.org)
* [Spring Boot Gradle Plugin Reference Guide](https://docs.spring.io/spring-boot/3.5.5/gradle-plugin)
* [Create an OCI image](https://docs.spring.io/spring-boot/3.5.5/gradle-plugin/packaging-oci-image.html)

### Additional Links

These additional references should also help you:

* [Gradle Build Scans – insights for your project's build](https://scans.gradle.com#gradle)


===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\HELP.md =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\securitybusinesssuite.iml =====
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$" />
    <orderEntry type="sourceFolder" forTests="false" />
  </component>
</module>
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\securitybusinesssuite.iml =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\settings.gradle.kts =====
// path: settings.gradle.kts
rootProject.name = "securitybusinesssuite"
include("data", "business", "web")
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\settings.gradle.kts =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\web\build.gradle.kts =====
// path: web/build.gradle.kts
plugins {
    id("org.springframework.boot")
    id("io.spring.dependency-management")
}

dependencies {
    implementation(project(":data"))
    implementation(project(":business"))

    implementation("org.springframework.boot:spring-boot-starter-web")
    implementation("org.springframework.boot:spring-boot-starter-security")
    implementation("org.springframework.boot:spring-boot-starter-oauth2-client")
    implementation("org.springframework.boot:spring-boot-starter-validation")

    compileOnly("org.projectlombok:lombok:1.18.34")
    annotationProcessor("org.projectlombok:lombok:1.18.34")

    developmentOnly("org.springframework.boot:spring-boot-devtools")

    testImplementation("org.springframework.boot:spring-boot-starter-test")
    testImplementation("org.springframework.security:spring-security-test")
}

springBoot {
    mainClass.set("com.securitybusinesssuite.web.SecurityBusinessSuiteApplication")
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\web\build.gradle.kts =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\web\src\main\java\com\securitybusinesssuite\web\config\CorsConfig.java =====
// path: web/src/main/java/com/securitybusinesssuite/web/config/CorsConfig.java
package com.securitybusinesssuite.web.config;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;

import java.util.Arrays;
import java.util.List;

@Configuration
public class CorsConfig {

    @Value("${app.frontend.url}")
    private String frontendUrl;

    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();
        configuration.setAllowedOrigins(List.of(frontendUrl));
        configuration.setAllowedMethods(Arrays.asList("GET", "POST", "PUT", "DELETE", "OPTIONS"));
        configuration.setAllowedHeaders(Arrays.asList("*"));
        configuration.setAllowCredentials(true);
        configuration.setMaxAge(3600L);

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", configuration);
        return source;
    }
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\web\src\main\java\com\securitybusinesssuite\web\config\CorsConfig.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\web\src\main\java\com\securitybusinesssuite\web\controller\AuthController.java =====
// path: web/src/main/java/com/securitybusinesssuite/web/controller/AuthController.java
package com.securitybusinesssuite.web.controller;

import com.securitybusinesssuite.business.dto.*;
import com.securitybusinesssuite.business.service.AuthService;
import com.securitybusinesssuite.business.service.JwtService;
import com.securitybusinesssuite.business.service.UserService;
import com.securitybusinesssuite.business.util.CookieUtil;
import com.securitybusinesssuite.web.security.UserPrincipal;
import jakarta.servlet.http.Cookie;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;

import java.io.IOException;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.util.Arrays;
import java.util.Map;
import java.util.UUID;

@Slf4j
@RestController
@RequestMapping("/auth")
@RequiredArgsConstructor
public class AuthController {

    private final AuthService authService;
    private final JwtService jwtService;
    private final UserService userService;
    private final CookieUtil cookieUtil;

    @Value("${app.frontend.url}")
    private String frontendUrl;

    @PostMapping("/register")
    public ResponseEntity<AuthResponse> register(@Valid @RequestBody RegisterRequest request) {
        AuthResponse response = authService.register(request);
        return ResponseEntity.status(HttpStatus.CREATED).body(response);
    }

    @PostMapping("/login")
    public ResponseEntity<Map<String, Object>> login(
            @Valid @RequestBody LoginRequest request,
            HttpServletResponse response) {

        TokenPair tokens = authService.login(request);

        // Set cookies
        response.addCookie(cookieUtil.createAccessTokenCookie(tokens.getAccessToken()));
        response.addCookie(cookieUtil.createRefreshTokenCookie(tokens.getRefreshToken()));

        return ResponseEntity.ok(Map.of(
                "message", "Login successful",
                "success", true
        ));
    }

    @GetMapping("/verify-email")
    public void verifyEmail(
            @RequestParam String token,
            HttpServletResponse response) throws IOException {
        try {
            String email = authService.verifyEmail(token);
            String encodedEmail = URLEncoder.encode(email, StandardCharsets.UTF_8);
            response.sendRedirect(frontendUrl + "/auth/callback?status=success&email="+encodedEmail);
        } catch (Exception e) {
            log.error("Email verification failed", e);
            response.sendRedirect(frontendUrl + "/auth/callback?status=error&message=" + e.getMessage());
        }
    }

    @PostMapping("/verify")
    public ResponseEntity<Map<String, Object>> verifyToken(HttpServletRequest request) {
        try {
            String accessToken = cookieUtil.extractTokenFromCookies(request, "access_token");

            if (accessToken == null) {
                return ResponseEntity.status(401).body(Map.of(
                        "valid", false,
                        "message", "No token provided"
                ));
            }

            // Validate token and get user info
            if (jwtService.validateToken(accessToken)) {
                String email = jwtService.getEmailFromToken(accessToken);
                UUID userId = jwtService.getUserIdFromToken(accessToken);

                return ResponseEntity.ok(Map.of(
                        "valid", true,
                        "email", email,
                        "userId", userId.toString()
                ));
            } else {
                return ResponseEntity.status(401).body(Map.of(
                        "valid", false,
                        "message", "Invalid token"
                ));
            }

        } catch (Exception e) {
            log.error("Token verification failed", e);
            return ResponseEntity.status(401).body(Map.of(
                    "valid", false,
                    "message", "Token verification failed"
            ));
        }
    }

    @PostMapping("/refresh")
    public ResponseEntity<Map<String, Object>> refresh(
            HttpServletRequest request,
            HttpServletResponse response) {

        String refreshToken = extractTokenFromCookie(request, "refresh_token");
        if (refreshToken == null) {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED)
                    .body(Map.of("error", "Refresh token not found"));
        }

        try {
            TokenPair tokens = authService.refresh(refreshToken);

            // Set new cookies
            response.addCookie(cookieUtil.createAccessTokenCookie(tokens.getAccessToken()));
            response.addCookie(cookieUtil.createRefreshTokenCookie(tokens.getRefreshToken()));

            return ResponseEntity.ok(Map.of(
                    "message", "Token refreshed successfully",
                    "success", true
            ));
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED)
                    .body(Map.of("error", e.getMessage()));
        }
    }

    @PostMapping("/logout")
    public ResponseEntity<Map<String, Object>> logout(HttpServletResponse response) {
        response.addCookie(cookieUtil.createLogoutCookie("access_token"));
        response.addCookie(cookieUtil.createLogoutCookie("refresh_token"));

        return ResponseEntity.ok(Map.of(
                "message", "Logout successful",
                "success", true
        ));
    }

    @GetMapping("/me")
    public ResponseEntity<UserDto> getCurrentUser(@AuthenticationPrincipal UserPrincipal principal) {
        if (principal == null) {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).build();
        }

        UserDto user = userService.getUserById(UUID.fromString(principal.getUserId()));
        return ResponseEntity.ok(user);
    }

    private String extractTokenFromCookie(HttpServletRequest request, String cookieName) {
        if (request.getCookies() == null) {
            return null;
        }

        return Arrays.stream(request.getCookies())
                .filter(cookie -> cookieName.equals(cookie.getName()))
                .map(Cookie::getValue)
                .findFirst()
                .orElse(null);
    }
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\web\src\main\java\com\securitybusinesssuite\web\controller\AuthController.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\web\src\main\java\com\securitybusinesssuite\web\controller\ClientController.java =====
// path: web/src/main/java/com/securitybusinesssuite/web/controller/ClientController.java
package com.securitybusinesssuite.web.controller;

import com.securitybusinesssuite.business.dto.*;
import com.securitybusinesssuite.business.dto.clientrequest.CreateClientRequestDTO;
import com.securitybusinesssuite.business.dto.clientrequest.UpdateClientRequestDTO;
import com.securitybusinesssuite.business.dto.invoiceresponse.InvoiceResponseDTO;
import com.securitybusinesssuite.business.dto.receiptresponse.ReceiptResponseDTO;
import com.securitybusinesssuite.business.dto.search.ClientSearchCriteria;
import com.securitybusinesssuite.business.dto.search.PagedResponseDTO;
import com.securitybusinesssuite.business.service.ClientService;
import com.securitybusinesssuite.business.service.InvoiceService;
import com.securitybusinesssuite.business.service.ReceiptService;
import com.securitybusinesssuite.data.entity.Client;
import com.securitybusinesssuite.web.security.UserPrincipal;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;
import java.util.UUID;

@RestController
@RequestMapping("/api/clients")
@RequiredArgsConstructor
public class ClientController {

    private final ClientService clientService;
    private final InvoiceService invoiceService;
    private final ReceiptService receiptService;

    @PostMapping
    public ResponseEntity<ClientResponseDTO> createClient(
            @Valid @RequestBody CreateClientRequestDTO request,
            @AuthenticationPrincipal UserPrincipal principal) {

        ClientResponseDTO client = clientService.createClient(request, UUID.fromString(principal.getUserId()));
        return ResponseEntity.status(HttpStatus.CREATED).body(client);
    }

    @GetMapping("/{id}")
    public ResponseEntity<ClientResponseDTO> getClient(@PathVariable UUID id) {
        ClientResponseDTO client = clientService.getClient(id);
        return ResponseEntity.ok(client);
    }

    @PutMapping("/{id}")
    public ResponseEntity<ClientResponseDTO> updateClient(
            @PathVariable UUID id,
            @Valid @RequestBody UpdateClientRequestDTO request,
            @AuthenticationPrincipal UserPrincipal principal) {

        ClientResponseDTO client = clientService.updateClient(id, request, UUID.fromString(principal.getUserId()));
        return ResponseEntity.ok(client);
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<Map<String, String>> deleteClient(@PathVariable UUID id) {
        clientService.deleteClient(id);
        return ResponseEntity.ok(Map.of("message", "Client deleted successfully"));
    }

    @GetMapping
    public ResponseEntity<PagedResponseDTO<ClientResponseDTO>> searchClients(
            @RequestParam(required = false) String businessName,
            @RequestParam(required = false) String clientType,
            @RequestParam(required = false) String status,
            @RequestParam(required = false) String businessSector,
            @RequestParam(required = false) String rnc,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "20") int size,
            @RequestParam(defaultValue = "createdAt") String sortBy,
            @RequestParam(defaultValue = "DESC") String sortDirection) {

        ClientSearchCriteria criteria = new ClientSearchCriteria();
        criteria.setBusinessName(businessName);
        criteria.setClientType(clientType != null ? Client.ClientType.valueOf(clientType.toUpperCase()) : null);
        criteria.setStatus(status != null ? Client.ClientStatus.valueOf(status.toUpperCase()) : null);
        criteria.setBusinessSector(businessSector != null ? Client.BusinessSector.valueOf(businessSector.toUpperCase()) : null);
        criteria.setRnc(rnc);
        criteria.setPage(page);
        criteria.setSize(size);
        criteria.setSortBy(sortBy);
        criteria.setSortDirection(sortDirection);

        PagedResponseDTO<ClientResponseDTO> result = clientService.searchClients(criteria);
        return ResponseEntity.ok(result);
    }

    @GetMapping("/{id}/invoices")
    public ResponseEntity<List<InvoiceResponseDTO>> getClientInvoices(@PathVariable UUID id) {
        List<InvoiceResponseDTO> invoices = invoiceService.getClientInvoices(id);
        return ResponseEntity.ok(invoices);
    }

    @GetMapping("/{id}/invoices/unpaid")
    public ResponseEntity<List<InvoiceResponseDTO>> getClientUnpaidInvoices(@PathVariable UUID id) {
        List<InvoiceResponseDTO> invoices = invoiceService.getUnpaidInvoices(id);
        return ResponseEntity.ok(invoices);
    }

    @GetMapping("/{id}/receipts")
    public ResponseEntity<List<ReceiptResponseDTO>> getClientReceipts(@PathVariable UUID id) {
        List<ReceiptResponseDTO> receipts = receiptService.getClientReceipts(id);
        return ResponseEntity.ok(receipts);
    }

    @PostMapping("/validate-rnc")
    public ResponseEntity<Map<String, Object>> validateRNC(@RequestBody Map<String, String> request) {
        String rnc = request.get("rnc");

        if (rnc == null || rnc.trim().isEmpty()) {
            return ResponseEntity.ok(Map.of("valid", true, "message", "RNC is optional"));
        }

        boolean exists = clientService.existsByRnc(rnc);
        if (exists) {
            return ResponseEntity.ok(Map.of(
                    "valid", false,
                    "message", "A client with this RNC already exists"
            ));
        }

        // Validate format
        if (!rnc.matches("\\d{3}-\\d{7}-\\d{1}")) {
            return ResponseEntity.ok(Map.of(
                    "valid", false,
                    "message", "RNC must be in format XXX-XXXXXXX-X"
            ));
        }

        return ResponseEntity.ok(Map.of("valid", true, "message", "RNC is valid"));
    }

    @GetMapping("/export")
    public ResponseEntity<Map<String, String>> exportClients(
            @RequestParam(required = false) String businessName,
            @RequestParam(required = false) String clientType,
            @RequestParam(required = false) String status,
            @RequestParam(required = false) String businessSector) {

        // TODO: Implement export functionality (CSV, Excel)
        return ResponseEntity.ok(Map.of("message", "Export functionality not implemented yet"));
    }
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\web\src\main\java\com\securitybusinesssuite\web\controller\ClientController.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\web\src\main\java\com\securitybusinesssuite\web\controller\DashboardController.java =====
// path: web/src/main/java/com/securitybusinesssuite/web/controller/DashboardController.java
package com.securitybusinesssuite.web.controller;

import com.securitybusinesssuite.business.dto.dashboard.ChartDataDTO;
import com.securitybusinesssuite.business.dto.dashboard.DashboardStatsDTO;
import com.securitybusinesssuite.business.dto.dashboard.RecentActivityDTO;
import com.securitybusinesssuite.business.service.DashboardService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

@RestController
@RequestMapping("/api/dashboard")
@RequiredArgsConstructor
public class DashboardController {

    private final DashboardService dashboardService;

    @GetMapping("/stats")
    public ResponseEntity<DashboardStatsDTO> getDashboardStats() {
        DashboardStatsDTO stats = dashboardService.getDashboardStats();
        return ResponseEntity.ok(stats);
    }

    @GetMapping("/recent-activity")
    public ResponseEntity<List<RecentActivityDTO>> getRecentActivity() {
        List<RecentActivityDTO> activities = dashboardService.getRecentActivity();
        return ResponseEntity.ok(activities);
    }

    @GetMapping("/charts/invoices-by-status")
    public ResponseEntity<List<ChartDataDTO>> getInvoicesByStatusChart() {
        List<ChartDataDTO> chartData = dashboardService.getInvoicesByStatusChart();
        return ResponseEntity.ok(chartData);
    }

    @GetMapping("/charts/revenue-by-month")
    public ResponseEntity<List<ChartDataDTO>> getRevenueByMonthChart() {
        List<ChartDataDTO> chartData = dashboardService.getRevenueByMonthChart();
        return ResponseEntity.ok(chartData);
    }

    @GetMapping("/charts/clients-by-type")
    public ResponseEntity<List<ChartDataDTO>> getClientsByTypeChart() {
        List<ChartDataDTO> chartData = dashboardService.getClientsByTypeChart();
        return ResponseEntity.ok(chartData);
    }
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\web\src\main\java\com\securitybusinesssuite\web\controller\DashboardController.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\web\src\main\java\com\securitybusinesssuite\web\controller\InvoiceController.java =====
// path: web/src/main/java/com/securitybusinesssuite/web/controller/InvoiceController.java
package com.securitybusinesssuite.web.controller;

import com.securitybusinesssuite.business.dto.*;
import com.securitybusinesssuite.business.dto.invoicerequest.CreateInvoiceRequestDTO;
import com.securitybusinesssuite.business.dto.invoicerequest.UpdateInvoiceRequestDTO;
import com.securitybusinesssuite.business.dto.invoiceresponse.InvoiceResponseDTO;
import com.securitybusinesssuite.business.dto.search.InvoiceSearchCriteria;
import com.securitybusinesssuite.business.dto.search.PagedResponseDTO;
import com.securitybusinesssuite.business.service.InvoiceService;
import com.securitybusinesssuite.data.entity.Invoice;
import com.securitybusinesssuite.web.security.UserPrincipal;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.List;
import java.util.Map;
import java.util.UUID;

@RestController
@RequestMapping("/api/invoices")
@RequiredArgsConstructor
public class InvoiceController {

    private final InvoiceService invoiceService;

    @PostMapping
    public ResponseEntity<InvoiceResponseDTO> createInvoice(
            @Valid @RequestBody CreateInvoiceRequestDTO request,
            @AuthenticationPrincipal UserPrincipal principal) {

        InvoiceResponseDTO invoice = invoiceService.createInvoice(request, UUID.fromString(principal.getUserId()));
        return ResponseEntity.status(HttpStatus.CREATED).body(invoice);
    }

    @GetMapping("/{id}")
    public ResponseEntity<InvoiceResponseDTO> getInvoice(@PathVariable UUID id) {
        InvoiceResponseDTO invoice = invoiceService.getInvoice(id);
        return ResponseEntity.ok(invoice);
    }

    @PutMapping("/{id}")
    public ResponseEntity<InvoiceResponseDTO> updateInvoice(
            @PathVariable UUID id,
            @Valid @RequestBody UpdateInvoiceRequestDTO request,
            @AuthenticationPrincipal UserPrincipal principal) {

        InvoiceResponseDTO invoice = invoiceService.updateInvoice(id, request, UUID.fromString(principal.getUserId()));
        return ResponseEntity.ok(invoice);
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<Map<String, String>> cancelInvoice(
            @PathVariable UUID id,
            @RequestBody(required = false) Map<String, String> request,
            @AuthenticationPrincipal UserPrincipal principal) {

        String reason = request != null ? request.get("reason") : "Cancelled by user";
        invoiceService.cancelInvoice(id, reason, UUID.fromString(principal.getUserId()));
        return ResponseEntity.ok(Map.of("message", "Invoice cancelled successfully"));
    }

    @GetMapping
    public ResponseEntity<PagedResponseDTO<InvoiceResponseDTO>> searchInvoices(
            @RequestParam(required = false) UUID clientId,
            @RequestParam(required = false) String clientName,
            @RequestParam(required = false) String status,
            @RequestParam(required = false) @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate fromDate,
            @RequestParam(required = false) @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate toDate,
            @RequestParam(required = false) BigDecimal minAmount,
            @RequestParam(required = false) BigDecimal maxAmount,
            @RequestParam(required = false) String invoiceNumber,
            @RequestParam(required = false) String ncf,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "20") int size,
            @RequestParam(defaultValue = "createdAt") String sortBy,
            @RequestParam(defaultValue = "DESC") String sortDirection) {

        InvoiceSearchCriteria criteria = new InvoiceSearchCriteria();
        criteria.setClientId(clientId);
        criteria.setClientName(clientName);
        criteria.setStatus(status != null ? Invoice.InvoiceStatus.valueOf(status.toUpperCase()) : null);
        criteria.setFromDate(fromDate);
        criteria.setToDate(toDate);
        criteria.setMinAmount(minAmount);
        criteria.setMaxAmount(maxAmount);
        criteria.setInvoiceNumber(invoiceNumber);
        criteria.setNcf(ncf);
        criteria.setPage(page);
        criteria.setSize(size);
        criteria.setSortBy(sortBy);
        criteria.setSortDirection(sortDirection);

        PagedResponseDTO<InvoiceResponseDTO> result = invoiceService.searchInvoices(criteria);
        return ResponseEntity.ok(result);
    }

    @PostMapping("/{id}/calculate")
    public ResponseEntity<InvoiceResponseDTO> recalculateInvoice(@PathVariable UUID id) {
        InvoiceResponseDTO invoice = invoiceService.recalculateInvoice(id);
        return ResponseEntity.ok(invoice);
    }

    @GetMapping("/overdue")
    public ResponseEntity<List<InvoiceResponseDTO>> getOverdueInvoices() {
        List<InvoiceResponseDTO> invoices = invoiceService.getOverdueInvoices();
        return ResponseEntity.ok(invoices);
    }

    @GetMapping("/{id}/pdf")
    public ResponseEntity<Map<String, String>> generateInvoicePDF(@PathVariable UUID id) {
        // TODO: Implement PDF generation
        return ResponseEntity.ok(Map.of(
                "message", "PDF generation not implemented yet",
                "invoiceId", id.toString()
        ));
    }

    @PostMapping("/bulk-create")
    public ResponseEntity<Map<String, Object>> bulkCreateInvoices(
            @Valid @RequestBody List<CreateInvoiceRequestDTO> requests,
            @AuthenticationPrincipal UserPrincipal principal) {

        // TODO: Implement bulk invoice creation
        return ResponseEntity.ok(Map.of(
                "message", "Bulk creation not implemented yet",
                "count", requests.size()
        ));
    }

    @GetMapping("/{id}/payment-history")
    public ResponseEntity<Map<String, Object>> getInvoicePaymentHistory(@PathVariable UUID id) {
        // TODO: Implement payment history retrieval
        return ResponseEntity.ok(Map.of(
                "message", "Payment history not implemented yet",
                "invoiceId", id.toString()
        ));
    }

    @PostMapping("/{id}/duplicate")
    public ResponseEntity<InvoiceResponseDTO> duplicateInvoice(
            @PathVariable UUID id,
            @AuthenticationPrincipal UserPrincipal principal) {

        // TODO: Implement invoice duplication
        throw new UnsupportedOperationException("Invoice duplication not implemented yet");
    }

    @PutMapping("/{id}/status")
    public ResponseEntity<Map<String, String>> updateInvoiceStatus(
            @PathVariable UUID id,
            @RequestBody Map<String, String> request,
            @AuthenticationPrincipal UserPrincipal principal) {

        String newStatus = request.get("status");
        // TODO: Implement manual status update with validation

        return ResponseEntity.ok(Map.of(
                "message", "Status update not implemented yet",
                "newStatus", newStatus
        ));
    }
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\web\src\main\java\com\securitybusinesssuite\web\controller\InvoiceController.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\web\src\main\java\com\securitybusinesssuite\web\controller\ReceiptController.java =====
// path: web/src/main/java/com/securitybusinesssuite/web/controller/ReceiptController.java
package com.securitybusinesssuite.web.controller;

import com.securitybusinesssuite.business.dto.*;
import com.securitybusinesssuite.business.dto.receiptrequest.CreateReceiptRequestDTO;
import com.securitybusinesssuite.business.dto.receiptrequest.PaymentAllocationDTO;
import com.securitybusinesssuite.business.dto.receiptrequest.UpdateReceiptRequestDTO;
import com.securitybusinesssuite.business.dto.receiptresponse.ReceiptAllocationResponseDTO;
import com.securitybusinesssuite.business.dto.receiptresponse.ReceiptResponseDTO;
import com.securitybusinesssuite.business.dto.search.PagedResponseDTO;
import com.securitybusinesssuite.business.dto.search.ReceiptSearchCriteria;
import com.securitybusinesssuite.business.service.ReceiptService;
import com.securitybusinesssuite.data.entity.Client;
import com.securitybusinesssuite.data.entity.Receipt;
import com.securitybusinesssuite.web.security.UserPrincipal;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.List;
import java.util.Map;
import java.util.UUID;

@RestController
@RequestMapping("/api/receipts")
@RequiredArgsConstructor
public class ReceiptController {

    private final ReceiptService receiptService;

    @PostMapping
    public ResponseEntity<ReceiptResponseDTO> createReceipt(
            @Valid @RequestBody CreateReceiptRequestDTO request,
            @AuthenticationPrincipal UserPrincipal principal) {

        ReceiptResponseDTO receipt = receiptService.createReceipt(request, UUID.fromString(principal.getUserId()));
        return ResponseEntity.status(HttpStatus.CREATED).body(receipt);
    }

    @GetMapping("/{id}")
    public ResponseEntity<ReceiptResponseDTO> getReceipt(@PathVariable UUID id) {
        ReceiptResponseDTO receipt = receiptService.getReceipt(id);
        return ResponseEntity.ok(receipt);
    }

    @PutMapping("/{id}")
    public ResponseEntity<ReceiptResponseDTO> updateReceipt(
            @PathVariable UUID id,
            @Valid @RequestBody UpdateReceiptRequestDTO request,
            @AuthenticationPrincipal UserPrincipal principal) {

        ReceiptResponseDTO receipt = receiptService.updateReceipt(id, request, UUID.fromString(principal.getUserId()));
        return ResponseEntity.ok(receipt);
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<Map<String, String>> voidReceipt(
            @PathVariable UUID id,
            @RequestBody(required = false) Map<String, String> request,
            @AuthenticationPrincipal UserPrincipal principal) {

        String reason = request != null ? request.get("reason") : "Voided by user";
        receiptService.voidReceipt(id, reason, UUID.fromString(principal.getUserId()));
        return ResponseEntity.ok(Map.of("message", "Receipt voided successfully"));
    }

    @GetMapping
    public ResponseEntity<PagedResponseDTO<ReceiptResponseDTO>> searchReceipts(
            @RequestParam(required = false) UUID clientId,
            @RequestParam(required = false) String clientName,
            @RequestParam(required = false) String status,
            @RequestParam(required = false) @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate fromDate,
            @RequestParam(required = false) @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate toDate,
            @RequestParam(required = false) String paymentMethod,
            @RequestParam(required = false) String receiptNumber,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "20") int size,
            @RequestParam(defaultValue = "createdAt") String sortBy,
            @RequestParam(defaultValue = "DESC") String sortDirection) {

        ReceiptSearchCriteria criteria = new ReceiptSearchCriteria();
        criteria.setClientId(clientId);
        criteria.setClientName(clientName);
        criteria.setStatus(status != null ? Receipt.ReceiptStatus.valueOf(status.toUpperCase()) : null);
        criteria.setFromDate(fromDate);
        criteria.setToDate(toDate);
        criteria.setPaymentMethod(paymentMethod != null ? Client.PaymentMethod.valueOf(paymentMethod.toUpperCase()) : null);
        criteria.setReceiptNumber(receiptNumber);
        criteria.setPage(page);
        criteria.setSize(size);
        criteria.setSortBy(sortBy);
        criteria.setSortDirection(sortDirection);

        PagedResponseDTO<ReceiptResponseDTO> result = receiptService.searchReceipts(criteria);
        return ResponseEntity.ok(result);
    }

    @PostMapping("/{id}/allocate")
    public ResponseEntity<Map<String, String>> allocatePayment(
            @PathVariable UUID id,
            @Valid @RequestBody List<PaymentAllocationDTO> allocations,
            @AuthenticationPrincipal UserPrincipal principal) {

        receiptService.allocatePayment(id, allocations, UUID.fromString(principal.getUserId()));
        return ResponseEntity.ok(Map.of("message", "Payment allocated successfully"));
    }

    @GetMapping("/{id}/available-amount")
    public ResponseEntity<Map<String, BigDecimal>> getAvailableAmount(@PathVariable UUID id) {
        BigDecimal availableAmount = receiptService.getAvailableAmount(id);
        return ResponseEntity.ok(Map.of("availableAmount", availableAmount));
    }

    @GetMapping("/{id}/pdf")
    public ResponseEntity<Map<String, String>> generateReceiptPDF(@PathVariable UUID id) {
        // TODO: Implement PDF generation
        return ResponseEntity.ok(Map.of(
                "message", "PDF generation not implemented yet",
                "receiptId", id.toString()
        ));
    }

    @PostMapping("/{id}/duplicate")
    public ResponseEntity<ReceiptResponseDTO> duplicateReceipt(
            @PathVariable UUID id,
            @AuthenticationPrincipal UserPrincipal principal) {

        // TODO: Implement receipt duplication
        throw new UnsupportedOperationException("Receipt duplication not implemented yet");
    }

    @GetMapping("/{id}/allocations")
    public ResponseEntity<List<ReceiptAllocationResponseDTO>> getReceiptAllocations(@PathVariable UUID id) {
        ReceiptResponseDTO receipt = receiptService.getReceipt(id);
        return ResponseEntity.ok(receipt.getAllocations());
    }

    @PostMapping("/bulk-void")
    public ResponseEntity<Map<String, Object>> bulkVoidReceipts(
            @RequestBody Map<String, Object> request,
            @AuthenticationPrincipal UserPrincipal principal) {

        // TODO: Implement bulk void functionality
        return ResponseEntity.ok(Map.of(
                "message", "Bulk void not implemented yet"
        ));
    }
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\web\src\main\java\com\securitybusinesssuite\web\controller\ReceiptController.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\web\src\main\java\com\securitybusinesssuite\web\exception\GlobalExceptionHandler.java =====
// path: web/src/main/java/com/securitybusinesssuite/web/exception/GlobalExceptionHandler.java
package com.securitybusinesssuite.web.exception;

import com.securitybusinesssuite.business.exception.AuthenticationException;
import com.securitybusinesssuite.business.exception.BusinessException;
import com.securitybusinesssuite.business.exception.UserAlreadyExistsException;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

import java.util.HashMap;
import java.util.Map;

@Slf4j
@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<Map<String, Object>> handleValidationExceptions(
            MethodArgumentNotValidException ex) {
        Map<String, String> errors = new HashMap<>();
        ex.getBindingResult().getAllErrors().forEach((error) -> {
            String fieldName = ((FieldError) error).getField();
            String errorMessage = error.getDefaultMessage();
            errors.put(fieldName, errorMessage);
        });

        return ResponseEntity.badRequest().body(Map.of(
                "error", "Validation failed",
                "details", errors
        ));
    }

    @ExceptionHandler(AuthenticationException.class)
    public ResponseEntity<Map<String, String>> handleAuthenticationException(
            AuthenticationException ex) {
        log.error("Authentication error: {}", ex.getMessage());
        return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(Map.of(
                "error", ex.getMessage()
        ));
    }

    @ExceptionHandler(UserAlreadyExistsException.class)
    public ResponseEntity<Map<String, String>> handleUserAlreadyExistsException(
            UserAlreadyExistsException ex) {
        return ResponseEntity.status(HttpStatus.CONFLICT).body(Map.of(
                "error", ex.getMessage()
        ));
    }

    @ExceptionHandler(BusinessException.class)
    public ResponseEntity<Map<String, String>> handleBusinessException(
            BusinessException ex) {
        log.error("Business error: {}", ex.getMessage());
        return ResponseEntity.badRequest().body(Map.of(
                "error", ex.getMessage()
        ));
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<Map<String, String>> handleGenericException(
            Exception ex) {
        log.error("Unexpected error", ex);
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(Map.of(
                "error", "An unexpected error occurred"
        ));
    }
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\web\src\main\java\com\securitybusinesssuite\web\exception\GlobalExceptionHandler.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\web\src\main\java\com\securitybusinesssuite\web\security\CustomOAuth2SuccessHandler.java =====
// path: web/src/main/java/com/securitybusinesssuite/web/security/CustomOAuth2SuccessHandler.java
package com.securitybusinesssuite.web.security;

import com.securitybusinesssuite.business.dto.OAuthResult;
import com.securitybusinesssuite.business.service.AuthService;
import com.securitybusinesssuite.business.service.JwtService;
import com.securitybusinesssuite.business.util.CookieUtil;
import com.securitybusinesssuite.data.entity.User;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Lazy;
import org.springframework.security.core.Authentication;
import org.springframework.security.oauth2.core.user.OAuth2User;
import org.springframework.security.web.authentication.SimpleUrlAuthenticationSuccessHandler;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.util.Map;

@Slf4j
@Component
public class CustomOAuth2SuccessHandler extends SimpleUrlAuthenticationSuccessHandler {

    private final AuthService authService;
    private final JwtService jwtService;
    private final CookieUtil cookieUtil;

    @Value("${app.frontend.url}")
    private String frontendUrl;

    // Add @Lazy to the constructor to break the circular dependency
    public CustomOAuth2SuccessHandler(@Lazy AuthService authService,
                                      JwtService jwtService,
                                      CookieUtil cookieUtil) {
        this.authService = authService;
        this.jwtService = jwtService;
        this.cookieUtil = cookieUtil;
    }

    @Override
    public void onAuthenticationSuccess(
            HttpServletRequest request,
            HttpServletResponse response,
            Authentication authentication) throws IOException {

        OAuth2User oAuth2User = (OAuth2User) authentication.getPrincipal();

        String email = oAuth2User.getAttribute("email");
        String provider = "GOOGLE";
        String providerId = oAuth2User.getName();
        Map<String, Object> attributes = oAuth2User.getAttributes();

        try {
            OAuthResult result = authService.processOAuthLogin(email, provider, providerId, attributes);
            User user = result.getUser();

            // Generate JWT tokens
            var tokens = jwtService.generateTokenPair(user.getId(), user.getEmail());

            // Set cookies
            response.addCookie(cookieUtil.createAccessTokenCookie(tokens.getAccessToken()));
            response.addCookie(cookieUtil.createRefreshTokenCookie(tokens.getRefreshToken()));

            String encodedEmail = URLEncoder.encode(email, StandardCharsets.UTF_8);

            // Redirect based on user status
            if (result.isNewUser()) {
                // First time registration - redirect to callback page
                getRedirectStrategy().sendRedirect(request, response,
                        frontendUrl + "/auth/callback?status=success&email=" + encodedEmail);
            } else {
                // Existing user login - redirect to dashboard
                getRedirectStrategy().sendRedirect(request, response,
                        frontendUrl + "/dashboard");
            }

        } catch (Exception e) {
            log.error("OAuth authentication failed", e);
            String encodedMessage = URLEncoder.encode(e.getMessage(), StandardCharsets.UTF_8);
            getRedirectStrategy().sendRedirect(request, response,
                    frontendUrl + "/auth/callback?status=error&message=" + encodedMessage);
        }
    }
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\web\src\main\java\com\securitybusinesssuite\web\security\CustomOAuth2SuccessHandler.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\web\src\main\java\com\securitybusinesssuite\web\security\CustomOAuth2UserService.java =====
// path: web/src/main/java/com/securitybusinesssuite/web/security/CustomOAuth2UserService.java
package com.securitybusinesssuite.web.security;

import lombok.extern.slf4j.Slf4j;
import org.springframework.security.oauth2.client.userinfo.DefaultOAuth2UserService;
import org.springframework.security.oauth2.client.userinfo.OAuth2UserRequest;
import org.springframework.security.oauth2.core.OAuth2AuthenticationException;
import org.springframework.security.oauth2.core.user.OAuth2User;
import org.springframework.stereotype.Service;

@Slf4j
@Service
public class CustomOAuth2UserService extends DefaultOAuth2UserService {

    @Override
    public OAuth2User loadUser(OAuth2UserRequest userRequest) throws OAuth2AuthenticationException {
        OAuth2User user = super.loadUser(userRequest);
        String email = user.getAttribute("email");
        // Log OAuth user info for debugging
        log.info("OAuth2 user loaded: {}", email!=null?email:"unknown");

        // Additional processing can be done here if needed
        return user;
    }
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\web\src\main\java\com\securitybusinesssuite\web\security\CustomOAuth2UserService.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\web\src\main\java\com\securitybusinesssuite\web\security\JwtAuthenticationFilter.java =====
// path: web/src/main/java/com/securitybusinesssuite/web/security/JwtAuthenticationFilter.java
package com.securitybusinesssuite.web.security;

import com.securitybusinesssuite.business.service.JwtService;
import com.securitybusinesssuite.business.service.UserService;
import com.securitybusinesssuite.data.entity.User;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.Cookie;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;
import java.util.Arrays;
import java.util.UUID;

@Slf4j
@Component
@RequiredArgsConstructor
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    private final JwtService jwtService;
    private final UserService userService;

    @Override
    protected void doFilterInternal(
            HttpServletRequest request,
            HttpServletResponse response,
            FilterChain filterChain) throws ServletException, IOException {

        String token = extractTokenFromCookie(request);

        if (token != null && jwtService.validateToken(token)) {
            try {
                String tokenType = jwtService.getTokenType(token);
                if ("access".equals(tokenType)) {
                    UUID userId = jwtService.getUserIdFromToken(token);
                    User user = userService.findById(userId);

                    UserPrincipal userPrincipal = UserPrincipal.create(user);
                    UsernamePasswordAuthenticationToken authentication =
                            new UsernamePasswordAuthenticationToken(userPrincipal, null, userPrincipal.getAuthorities());
                    authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));

                    SecurityContextHolder.getContext().setAuthentication(authentication);
                }
            } catch (Exception e) {
                log.error("Cannot set user authentication", e);
            }
        }

        filterChain.doFilter(request, response);
    }

    private String extractTokenFromCookie(HttpServletRequest request) {
        if (request.getCookies() == null) {
            return null;
        }

        return Arrays.stream(request.getCookies())
                .filter(cookie -> "access_token".equals(cookie.getName()))
                .map(Cookie::getValue)
                .findFirst()
                .orElse(null);
    }
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\web\src\main\java\com\securitybusinesssuite\web\security\JwtAuthenticationFilter.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\web\src\main\java\com\securitybusinesssuite\web\security\SecurityConfig.java =====
// path: web/src/main/java/com/securitybusinesssuite/web/security/SecurityConfig.java
package com.securitybusinesssuite.web.security;

import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.web.cors.CorsConfigurationSource;

@Configuration
@EnableWebSecurity
@RequiredArgsConstructor
public class SecurityConfig {

    private final JwtAuthenticationFilter jwtAuthenticationFilter;
    private final CustomOAuth2SuccessHandler oAuth2SuccessHandler;
    private final CustomOAuth2UserService customOAuth2UserService;
    private final CorsConfigurationSource corsConfigurationSource;
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
                .cors(cors -> cors.configurationSource(corsConfigurationSource)) // ← Add this line
                .csrf(csrf -> csrf.disable())
                .sessionManagement(session -> session
                        .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                )
                .authorizeHttpRequests(auth -> auth
                        .requestMatchers(
                                "/auth/register",
                                "/auth/login",
                                "/auth/verify-email",
                                "/auth/refresh",
                                "/auth/verify",
                                "/oauth2/**"
                        ).permitAll()
                        .anyRequest().authenticated()
                )
                .oauth2Login(oauth2 -> oauth2
                        .userInfoEndpoint(userInfo -> userInfo
                                .userService(customOAuth2UserService)
                        )
                        .successHandler(oAuth2SuccessHandler)
                )
                .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\web\src\main\java\com\securitybusinesssuite\web\security\SecurityConfig.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\web\src\main\java\com\securitybusinesssuite\web\security\UserPrincipal.java =====
// path: web/src/main/java/com/securitybusinesssuite/web/security/UserPrincipal.java
package com.securitybusinesssuite.web.security;

import com.securitybusinesssuite.data.entity.User;
import lombok.AllArgsConstructor;
import lombok.Data;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

import java.util.Collection;
import java.util.Collections;

@Data
@AllArgsConstructor
public class UserPrincipal implements UserDetails {

    private String userId;
    private String email;
    private String password;
    private Collection<? extends GrantedAuthority> authorities;

    public static UserPrincipal create(User user) {
        return new UserPrincipal(
                user.getId().toString(),
                user.getEmail(),
                user.getPasswordHash(),
                Collections.singletonList(new SimpleGrantedAuthority("ROLE_USER"))
        );
    }

    @Override
    public String getUsername() {
        return email;
    }

    @Override
    public boolean isAccountNonExpired() {
        return true;
    }

    @Override
    public boolean isAccountNonLocked() {
        return true;
    }

    @Override
    public boolean isCredentialsNonExpired() {
        return true;
    }

    @Override
    public boolean isEnabled() {
        return true;
    }
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\web\src\main\java\com\securitybusinesssuite\web\security\UserPrincipal.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\web\src\main\java\com\securitybusinesssuite\web\SecurityBusinessSuiteApplication.java =====
// path: web/src/main/java/com/securitybusinesssuite/web/SecurityBusinessSuiteApplication.java
package com.securitybusinesssuite.web;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.ComponentScan;

@SpringBootApplication
@ComponentScan(basePackages = "com.securitybusinesssuite")
public class SecurityBusinessSuiteApplication {
    public static void main(String[] args) {
        SpringApplication.run(SecurityBusinessSuiteApplication.class, args);
    }
}
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\web\src\main\java\com\securitybusinesssuite\web\SecurityBusinessSuiteApplication.java =====

===== BEGIN FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\web\src\main\resources\application.yml =====
# path: web/src/main/resources/application.yml
spring:
  application:
    name: security-business-suite
  profiles:
    active: dev
  datasource:
    url: ${DB_URL}
    username: ${DB_USER}
    password: ${DB_PASS}
    hikari:
      maximum-pool-size: ${DATABASE_POOL_SIZE:10}
      minimum-idle: 2
      connection-timeout: 30000
      idle-timeout: 600000
      max-lifetime: 1800000

  flyway:
    enabled: true
    baseline-on-migrate: true
    locations: classpath:db/migration

  mail:
    host: ${MAIL_HOST}
    port: ${MAIL_PORT}
    username: ${MAIL_USERNAME}
    password: ${MAIL_PASSWORD}
    from: ${MAIL_FROM}
    properties:
      mail:
        smtp:
          auth: true
          starttls:
            enable: true
            required: true

  security:
    oauth2:
      client:
        registration:
          google:
            client-id: ${GOOGLE_CLIENT_ID}
            client-secret: ${GOOGLE_CLIENT_SECRET}
            scope:
              - email
              - profile
            redirect-uri: "{baseUrl}/login/oauth2/code/{registrationId}"
        provider:
          google:
            authorization-uri: https://accounts.google.com/o/oauth2/v2/auth
            token-uri: https://oauth2.googleapis.com/token
            user-info-uri: https://www.googleapis.com/oauth2/v3/userinfo
            user-name-attribute: sub

app:
  jwt:
    secret: ${JWT_SECRET}
    access-token-expiration: ${JWT_ACCESS_TOKEN_EXPIRATION:900}
    refresh-token-expiration: ${JWT_REFRESH_TOKEN_EXPIRATION:604800}

  frontend:
    url: ${FRONTEND_URL:http://localhost:3000}

  backend:
    url: ${BACKEND_URL:http://localhost:8080}

  cookie:
    secure: ${COOKIE_SECURE:false}
    domain: ${COOKIE_DOMAIN:localhost}

server:
  port: ${SERVER_PORT:8080}
  servlet:
    context-path: ${SERVER_CONTEXT_PATH:/}

logging:
  level:
    root: INFO
    com.securitybusinesssuite: DEBUG
    org.springframework.security: DEBUG
===== END FILE: C:\Users\alexr\IdeaProjects\securitybusinesssuite\web\src\main\resources\application.yml =====

